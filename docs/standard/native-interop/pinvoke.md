---
title: Invocação de plataforma (P/Invoke)
description: Saiba como chamar funções nativas via P/Invoke no .NET.
ms.date: 01/18/2019
ms.openlocfilehash: cde52d9d0a4e3b84fec632b615b635e7b7df3924
ms.sourcegitcommit: 4b79862c5b41fbd86cf38f926f6a49516059f6f2
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/18/2020
ms.locfileid: "97678264"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="b5437-103">Invocação de plataforma (P/Invoke)</span><span class="sxs-lookup"><span data-stu-id="b5437-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="b5437-104">P/Invoke é uma tecnologia que permite acessar structs, retornos de chamada e funções em bibliotecas não gerenciadas de um código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b5437-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="b5437-105">A maior parte da API do P/Invoke está contida em dois namespaces: `System` e `System.Runtime.InteropServices`.</span><span class="sxs-lookup"><span data-stu-id="b5437-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="b5437-106">O uso desses dois namespaces fornece as ferramentas que descrevem como você deseja se comunicar com o componente nativo.</span><span class="sxs-lookup"><span data-stu-id="b5437-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="b5437-107">Vamos começar com exemplo mais comum, que é chamar funções não gerenciadas no seu código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b5437-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="b5437-108">Vamos mostrar uma caixa de mensagem de um aplicativo de linha de comando:</span><span class="sxs-lookup"><span data-stu-id="b5437-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="b5437-109">O exemplo anterior é simples, mas mostra o que é necessário para invocar funções não gerenciadas de um código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b5437-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="b5437-110">Vamos analisar o exemplo:</span><span class="sxs-lookup"><span data-stu-id="b5437-110">Let’s step through the example:</span></span>

- <span data-ttu-id="b5437-111">A linha #2 mostra a instrução using para o `System.Runtime.InteropServices` namespace que contém todos os itens necessários.</span><span class="sxs-lookup"><span data-stu-id="b5437-111">Line #2 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="b5437-112">A linha #8 apresenta o `DllImport` atributo.</span><span class="sxs-lookup"><span data-stu-id="b5437-112">Line #8 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="b5437-113">Esse atributo é crucial, pois informa ao runtime que deve carregar a DLL não gerenciada.</span><span class="sxs-lookup"><span data-stu-id="b5437-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="b5437-114">A cadeia de caracteres passada é a DLL na qual nossa função de destino está incluída.</span><span class="sxs-lookup"><span data-stu-id="b5437-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="b5437-115">Além disso, especifica qual [conjunto de caracteres](./charset.md) deve ser usado para realizar marshaling de cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="b5437-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="b5437-116">Por fim, especifica que essa função chama [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) e que o runtime deve capturar esse código de erro para que o usuário possa recuperá-lo via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b5437-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="b5437-117">A linha #9 é a crux do trabalho P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="b5437-117">Line #9 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="b5437-118">Define um método gerenciado que tem **exatamente a mesma assinatura** que o não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b5437-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="b5437-119">A declaração tem uma nova palavra-chave que você pode observar, `extern`, que informa ao runtime que é um método externo; quando invocado, o runtime deve encontrá-la na DLL especificada no atributo `DllImport`.</span><span class="sxs-lookup"><span data-stu-id="b5437-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="b5437-120">O restante do exemplo é simplesmente chamar o método como você faria com qualquer outro método gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b5437-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="b5437-121">A amostra é semelhante para macOS.</span><span class="sxs-lookup"><span data-stu-id="b5437-121">The sample is similar for macOS.</span></span> <span data-ttu-id="b5437-122">O nome da biblioteca deve ser alterado no atributo `DllImport`, pois o macOS tem um esquema diferente de nomenclatura para bibliotecas dinâmicas.</span><span class="sxs-lookup"><span data-stu-id="b5437-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="b5437-123">O exemplo a seguir usa a função `getpid(2)` para obter a ID do processo do aplicativo e imprimi-la para o console:</span><span class="sxs-lookup"><span data-stu-id="b5437-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="b5437-124">Também é semelhante no Linux.</span><span class="sxs-lookup"><span data-stu-id="b5437-124">It is also similar on Linux.</span></span> <span data-ttu-id="b5437-125">O nome da função é o mesmo, já que `getpid(2)` é uma chamada do sistema [POSIX](https://en.wikipedia.org/wiki/POSIX) padrão.</span><span class="sxs-lookup"><span data-stu-id="b5437-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="b5437-126">Chamando código gerenciado do código não gerenciado</span><span class="sxs-lookup"><span data-stu-id="b5437-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="b5437-127">O runtime viabiliza o fluxo da comunicação nas duas direções, o que permite retornar a chamada no código gerenciado das funções nativas usando ponteiros de função.</span><span class="sxs-lookup"><span data-stu-id="b5437-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="b5437-128">A coisa mais próxima a um ponteiro de função no código gerenciado é um **delegado**; portanto, isso é usado para permitir retornos de chamada do código nativo para o código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b5437-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="b5437-129">A maneira de usar esse recurso é semelhante ao processo gerenciado para nativo, conforme descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="b5437-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="b5437-130">Para um retorno de chamada específico, você define um delegado que corresponda à assinatura e o passa para o método externo.</span><span class="sxs-lookup"><span data-stu-id="b5437-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="b5437-131">O runtime cuidará do resto.</span><span class="sxs-lookup"><span data-stu-id="b5437-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="b5437-132">Antes de analisar o exemplo, é uma boa ideia examinar as assinaturas das funções não gerenciadas com as quais você precisa trabalhar.</span><span class="sxs-lookup"><span data-stu-id="b5437-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="b5437-133">A função a ser chamada para enumerar todas as janelas tem esta assinatura: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="b5437-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="b5437-134">O primeiro parâmetro é um retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="b5437-134">The first parameter is a callback.</span></span> <span data-ttu-id="b5437-135">Esse retorno de chamada tem a seguinte assinatura: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="b5437-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="b5437-136">Agora, vamos analisar o exemplo:</span><span class="sxs-lookup"><span data-stu-id="b5437-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="b5437-137">A linha 9 no exemplo define um delegado que corresponde à assinatura do retorno de chamada do código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b5437-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="b5437-138">Observe como os tipos LPARAM e HWND são representados usando `IntPtr` no código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="b5437-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="b5437-139">As linhas 13 e 14 introduzem a função `EnumWindows` da biblioteca user32.dll.</span><span class="sxs-lookup"><span data-stu-id="b5437-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="b5437-140">As linhas de 17 a 20 implementam o delegado.</span><span class="sxs-lookup"><span data-stu-id="b5437-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="b5437-141">Neste exemplo simples, queremos apenas produzir o identificador para o console.</span><span class="sxs-lookup"><span data-stu-id="b5437-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="b5437-142">Por fim, na linha 24, chamamos o método externo e passamos o delegado.</span><span class="sxs-lookup"><span data-stu-id="b5437-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="b5437-143">Os exemplos de Linux e macOS são mostrados abaixo.</span><span class="sxs-lookup"><span data-stu-id="b5437-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="b5437-144">Para eles, usamos a função `ftw` que pode ser encontrada em `libc`, a biblioteca C.</span><span class="sxs-lookup"><span data-stu-id="b5437-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="b5437-145">Essa função é usada para percorrer as hierarquias de diretório e leva um ponteiro para uma função como um dos seus parâmetros.</span><span class="sxs-lookup"><span data-stu-id="b5437-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="b5437-146">Essa função tem a seguinte assinatura: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span><span class="sxs-lookup"><span data-stu-id="b5437-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="b5437-147">O exemplo do macOS usa a mesma função; a única diferença é o argumento para o atributo `DllImport`, pois o macOS mantém `libc` em um local diferente.</span><span class="sxs-lookup"><span data-stu-id="b5437-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="b5437-148">Os exemplos anteriores dependem de parâmetros e, em ambos os casos, os parâmetros são fornecidos como tipos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="b5437-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="b5437-149">O runtime faz a "coisa certa" e processa esses parâmetros em seus equivalentes no outro lado.</span><span class="sxs-lookup"><span data-stu-id="b5437-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="b5437-150">Saiba mais sobre é realizado o marshaling de tipos para código nativo em nossa página sobre [Marshaling de tipo](type-marshaling.md).</span><span class="sxs-lookup"><span data-stu-id="b5437-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="b5437-151">Mais recursos</span><span class="sxs-lookup"><span data-stu-id="b5437-151">More resources</span></span>

- <span data-ttu-id="b5437-152">[Wiki do PInvoke.net](https://www.pinvoke.net/) uma wiki excelente com informações sobre as APIs comuns do Windows e como chamá-las.</span><span class="sxs-lookup"><span data-stu-id="b5437-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="b5437-153">P/Invoke em C++/CLI</span><span class="sxs-lookup"><span data-stu-id="b5437-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="b5437-154">Documentação do Mono no P/Invoke</span><span class="sxs-lookup"><span data-stu-id="b5437-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)
