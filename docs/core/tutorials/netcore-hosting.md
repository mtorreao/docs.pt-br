---
title: Escrever um host de runtime personalizado do .NET Core
description: Saiba como hospedar o runtime do .NET Core a partir do código nativo para dar suporte a cenários avançados que exigem o controle de como o runtime do .NET Core funciona.
author: mjrousos
ms.topic: how-to
ms.date: 12/21/2018
ms.openlocfilehash: 358cbff1ded3bd4ee9a3f78965eac1e1b1883ede
ms.sourcegitcommit: 635a0ff775d2447a81ef7233a599b8f88b162e5d
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/17/2020
ms.locfileid: "97633839"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="c932a-103">Escreva um host personalizado do .NET Core para controlar o runtime do .NET a partir de seu código nativo</span><span class="sxs-lookup"><span data-stu-id="c932a-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="c932a-104">Como todo código gerenciado, os aplicativos .NET Core são executados por um host.</span><span class="sxs-lookup"><span data-stu-id="c932a-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="c932a-105">O host é responsável por iniciar o runtime (incluindo componentes como JIT e coletor de lixo) e invocar pontos de entrada gerenciados.</span><span class="sxs-lookup"><span data-stu-id="c932a-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector) and invoking managed entry points.</span></span>

<span data-ttu-id="c932a-106">Hospedar o runtime do .NET Core é um cenário avançado e, na maioria dos casos, os desenvolvedores do .NET Core não precisam se preocupar com a hospedagem, pois os processos de build do .NET Core fornecem um host padrão para executar aplicativos .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c932a-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="c932a-107">No entanto, em algumas circunstâncias especializadas, pode ser útil hospedar explicitamente o runtime do .NET Core, como uma maneira de invocar o código gerenciado em um processo nativo ou para ter mais controle sobre o funcionamento do runtime.</span><span class="sxs-lookup"><span data-stu-id="c932a-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="c932a-108">Este artigo fornece uma visão geral das etapas necessárias para iniciar o runtime do .NET Core com base no código nativo e executar o código gerenciado nele.</span><span class="sxs-lookup"><span data-stu-id="c932a-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="c932a-109">Pré-requisitos</span><span class="sxs-lookup"><span data-stu-id="c932a-109">Prerequisites</span></span>

<span data-ttu-id="c932a-110">Como os hosts são aplicativos nativos, este tutorial aborda a construção de um aplicativo C++ para hospedar o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c932a-110">Because hosts are native applications, this tutorial covers constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="c932a-111">Você precisará de um ambiente de desenvolvimento do C++ (como aquele fornecido pelo [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span><span class="sxs-lookup"><span data-stu-id="c932a-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="c932a-112">Você também desejará ter um aplicativo .NET Core simples com o qual testará o host e, portanto, deverá instalar o [SDK do .NET Core](https://dotnet.microsoft.com/download) e [compilar um aplicativo .NET Core de teste pequeno](with-visual-studio.md) (como um aplicativo “Olá, Mundo”).</span><span class="sxs-lookup"><span data-stu-id="c932a-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://dotnet.microsoft.com/download) and [build a small .NET Core test app](with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="c932a-113">O aplicativo “Olá, Mundo” criado pelo novo modelo de projeto de console do .NET Core é suficiente.</span><span class="sxs-lookup"><span data-stu-id="c932a-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

## <a name="hosting-apis"></a><span data-ttu-id="c932a-114">APIs de hospedagem</span><span class="sxs-lookup"><span data-stu-id="c932a-114">Hosting APIs</span></span>

<span data-ttu-id="c932a-115">Há duas APIs diferentes que podem ser usadas para hospedar o .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c932a-115">There are two different APIs that can be used to host .NET Core.</span></span> <span data-ttu-id="c932a-116">Este artigo (e seus [exemplos](https://github.com/dotnet/samples/tree/master/core/hosting)associados) abrange essas duas opções.</span><span class="sxs-lookup"><span data-stu-id="c932a-116">This article (and its associated [samples](https://github.com/dotnet/samples/tree/master/core/hosting)) covers these 2 options.</span></span>

* <span data-ttu-id="c932a-117">O método preferencial de hospedar o runtime do .NET Core no .NET Core 3.0 e posteriores é com as APIs das bibliotecas `nethost` e `hostfxr`.</span><span class="sxs-lookup"><span data-stu-id="c932a-117">The preferred method of hosting the .NET Core runtime in .NET Core 3.0 and above is with the `nethost` and `hostfxr` libraries' APIs.</span></span> <span data-ttu-id="c932a-118">Esses pontos de entrada tratam a complexidade de localizar e configurar o runtime para inicialização, bem como permitem iniciar um aplicativo gerenciado e chamar um método gerenciado estático.</span><span class="sxs-lookup"><span data-stu-id="c932a-118">These entry points handle the complexity of finding and setting up the runtime for initialization and allow both launching a managed application and calling into a static managed method.</span></span>
* <span data-ttu-id="c932a-119">O método preferencial de hospedar o tempo de execução do .NET Core antes do .NET Core 3,0 é com a [`coreclrhost.h`](https://github.com/dotnet/runtime/blob/master/src/coreclr/hosts/inc/coreclrhost.h) API.</span><span class="sxs-lookup"><span data-stu-id="c932a-119">The preferred method of hosting the .NET Core runtime prior to .NET Core 3.0 is with the [`coreclrhost.h`](https://github.com/dotnet/runtime/blob/master/src/coreclr/hosts/inc/coreclrhost.h) API.</span></span> <span data-ttu-id="c932a-120">Essa API expõe funções para iniciar e interromper facilmente o runtime e invocar o código gerenciado (iniciando um exe gerenciado ou chamando métodos estáticos gerenciados).</span><span class="sxs-lookup"><span data-stu-id="c932a-120">This API exposes functions for easily starting and stopping the runtime and invoking managed code (either by launching a managed exe or by calling static managed methods).</span></span>

## <a name="sample-hosts"></a><span data-ttu-id="c932a-121">Hosts de exemplo</span><span class="sxs-lookup"><span data-stu-id="c932a-121">Sample Hosts</span></span>

<span data-ttu-id="c932a-122">Há [hosts de exemplo](https://github.com/dotnet/samples/tree/master/core/hosting) que demonstram as etapas descritas nos tutoriais abaixo disponíveis no repositório dotnet/samples do GitHub.</span><span class="sxs-lookup"><span data-stu-id="c932a-122">[Sample hosts](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in the tutorials below are available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="c932a-123">Os comentários nos exemplos associam claramente as etapas numeradas destes tutoriais aos pontos em que elas são executadas no exemplo.</span><span class="sxs-lookup"><span data-stu-id="c932a-123">Comments in the samples clearly associate the numbered steps from these tutorials with where they're performed in the sample.</span></span> <span data-ttu-id="c932a-124">Para obter instruções de download, consulte [Exemplos e tutoriais](../../samples-and-tutorials/index.md#view-and-download-samples).</span><span class="sxs-lookup"><span data-stu-id="c932a-124">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#view-and-download-samples).</span></span>

<span data-ttu-id="c932a-125">Lembre-se de que os hosts de exemplo devem ser usados para fins de aprendizado e, portanto, não fazem uma verificação de erros rigorosa e são projetados para enfatizar a legibilidade e não a eficiência.</span><span class="sxs-lookup"><span data-stu-id="c932a-125">Keep in mind that the sample hosts are meant to be used for learning purposes, so they are light on error checking and are designed to emphasize readability over efficiency.</span></span>

## <a name="create-a-host-using-nethosth-and-hostfxrh"></a><span data-ttu-id="c932a-126">Criar um host usando o `nethost.h` e o `hostfxr.h`</span><span class="sxs-lookup"><span data-stu-id="c932a-126">Create a host using `nethost.h` and `hostfxr.h`</span></span>

<span data-ttu-id="c932a-127">As etapas a seguir detalham como usar as bibliotecas `nethost` e `hostfxr` para iniciar o runtime do .NET Core em um aplicativo nativo e chamar um método estático gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-127">The following steps detail how to use the `nethost` and `hostfxr` libraries to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="c932a-128">O [exemplo](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) usa o `nethost` cabeçalho e a biblioteca instalados com o SDK do .net e copia [`coreclr_delegates.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/coreclr_delegates.h) os [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) arquivos e do repositório [dotnet/tempo de execução](https://github.com/dotnet/runtime) .</span><span class="sxs-lookup"><span data-stu-id="c932a-128">The [sample](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) uses the `nethost` header and library installed with the .NET SDK and copies of the [`coreclr_delegates.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/coreclr_delegates.h) and [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) files from the [dotnet/runtime](https://github.com/dotnet/runtime) repository.</span></span>

### <a name="step-1---load-hostfxr-and-get-exported-hosting-functions"></a><span data-ttu-id="c932a-129">Etapa 1-carregar `hostfxr` e obter funções de hospedagem exportadas</span><span class="sxs-lookup"><span data-stu-id="c932a-129">Step 1 - Load `hostfxr` and get exported hosting functions</span></span>

<span data-ttu-id="c932a-130">A biblioteca `nethost` fornece a função `get_hostfxr_path` para localizar a biblioteca `hostfxr`.</span><span class="sxs-lookup"><span data-stu-id="c932a-130">The `nethost` library provides the `get_hostfxr_path` function for locating the `hostfxr` library.</span></span> <span data-ttu-id="c932a-131">A biblioteca `hostfxr` expõe funções para hospedar o runtime do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c932a-131">The `hostfxr` library exposes functions for hosting the .NET Core runtime.</span></span> <span data-ttu-id="c932a-132">A lista completa de funções pode ser encontrada no [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) e no [documento de design de hospedagem nativa](https://github.com/dotnet/runtime/blob/master/docs/design/features/native-hosting.md).</span><span class="sxs-lookup"><span data-stu-id="c932a-132">The full list of functions can be found in [`hostfxr.h`](https://github.com/dotnet/runtime/blob/master/src/installer/corehost/cli/hostfxr.h) and the [native hosting design document](https://github.com/dotnet/runtime/blob/master/docs/design/features/native-hosting.md).</span></span> <span data-ttu-id="c932a-133">A amostra e este tutorial usam o seguinte:</span><span class="sxs-lookup"><span data-stu-id="c932a-133">The sample and this tutorial use the following:</span></span>

* <span data-ttu-id="c932a-134">`hostfxr_initialize_for_runtime_config`: Inicializa um contexto de host e se prepara para a inicialização do tempo de execução do .NET Core usando a configuração de tempo de execução especificada.</span><span class="sxs-lookup"><span data-stu-id="c932a-134">`hostfxr_initialize_for_runtime_config`: Initializes a host context and prepares for initialization of the .NET Core runtime using the specified runtime configuration.</span></span>
* <span data-ttu-id="c932a-135">`hostfxr_get_runtime_delegate`: Obtém um delegado para a funcionalidade de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="c932a-135">`hostfxr_get_runtime_delegate`: Gets a delegate for runtime functionality.</span></span>
* <span data-ttu-id="c932a-136">`hostfxr_close`: Fecha um contexto de host.</span><span class="sxs-lookup"><span data-stu-id="c932a-136">`hostfxr_close`: Closes a host context.</span></span>

<span data-ttu-id="c932a-137">A biblioteca `hostfxr` é encontrada usando `get_hostfxr_path`.</span><span class="sxs-lookup"><span data-stu-id="c932a-137">The `hostfxr` library is found using `get_hostfxr_path`.</span></span> <span data-ttu-id="c932a-138">Ela é carregada e suas exportações são recuperadas.</span><span class="sxs-lookup"><span data-stu-id="c932a-138">It is then loaded and its exports are retrieved.</span></span>

[!code-cpp[HostFxrHost#LoadHostFxr](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadHostFxr)]

### <a name="step-2---initialize-and-start-the-net-core-runtime"></a><span data-ttu-id="c932a-139">Etapa 2 – Inicializar e iniciar o runtime do .NET Core</span><span class="sxs-lookup"><span data-stu-id="c932a-139">Step 2 - Initialize and start the .NET Core runtime</span></span>

<span data-ttu-id="c932a-140">As funções `hostfxr_initialize_for_runtime_config` e `hostfxr_get_runtime_delegate` inicializam e iniciam o runtime do .NET Core usando a configuração do runtime para o componente gerenciado que será carregado.</span><span class="sxs-lookup"><span data-stu-id="c932a-140">The `hostfxr_initialize_for_runtime_config` and `hostfxr_get_runtime_delegate` functions initialize and start the .NET Core runtime using the runtime configuration for the managed component that will be loaded.</span></span> <span data-ttu-id="c932a-141">A função `hostfxr_get_runtime_delegate` é usada para obter um representante do runtime que permite carregar um assembly gerenciado e obter um ponteiro de função para um método estático no assembly em questão.</span><span class="sxs-lookup"><span data-stu-id="c932a-141">The `hostfxr_get_runtime_delegate` function is used to get a runtime delegate that allows loading a managed assembly and getting a function pointer to a static method in that assembly.</span></span>

[!code-cpp[HostFxrHost#Initialize](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#Initialize)]

### <a name="step-3---load-managed-assembly-and-get-function-pointer-to-a-managed-method"></a><span data-ttu-id="c932a-142">Etapa 3 – Carregar o assembly gerenciado e obter o ponteiro de função para um método gerenciado</span><span class="sxs-lookup"><span data-stu-id="c932a-142">Step 3 - Load managed assembly and get function pointer to a managed method</span></span>

<span data-ttu-id="c932a-143">O representante do runtime é chamado para carregar o assembly gerenciado e obter um ponteiro de função para um método gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-143">The runtime delegate is called to load the managed assembly and get a function pointer to a managed method.</span></span> <span data-ttu-id="c932a-144">O representante exige o caminho do assembly, o nome do tipo e o nome do método como entradas e retorna um ponteiro de função que pode ser usado para invocar o método gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-144">The delegate requires the assembly path, type name, and method name as inputs and returns a function pointer that can be used to invoke the managed method.</span></span>

[!code-cpp[HostFxrHost#LoadAndGet](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadAndGet)]

<span data-ttu-id="c932a-145">Ao passar `nullptr` como o nome do tipo de representante chamando o representante do runtime, a amostra usa uma assinatura padrão para o método gerenciado:</span><span class="sxs-lookup"><span data-stu-id="c932a-145">By passing `nullptr` as the delegate type name when calling the runtime delegate, the sample uses a default signature for the managed method:</span></span>

```csharp
public delegate int ComponentEntryPoint(IntPtr args, int sizeBytes);
```

<span data-ttu-id="c932a-146">Uma assinatura diferente pode ser usada especificando o nome do tipo de representante ao chamar o representante do runtime.</span><span class="sxs-lookup"><span data-stu-id="c932a-146">A different signature can be used by specifying the delegate type name when calling the runtime delegate.</span></span>

### <a name="step-4---run-managed-code"></a><span data-ttu-id="c932a-147">Etapa 4 – Executar o código gerenciado!</span><span class="sxs-lookup"><span data-stu-id="c932a-147">Step 4 - Run managed code!</span></span>

<span data-ttu-id="c932a-148">O host nativo agora pode chamar o método gerenciado e passar a ele os parâmetros desejados.</span><span class="sxs-lookup"><span data-stu-id="c932a-148">The native host can now call the managed method and pass it the desired parameters.</span></span>

[!code-cpp[HostFxrHost#CallManaged](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithHostFxr/src/NativeHost/nativehost.cpp#CallManaged)]

## <a name="create-a-host-using-coreclrhosth"></a><span data-ttu-id="c932a-149">Criar um host usando `coreclrhost.h`</span><span class="sxs-lookup"><span data-stu-id="c932a-149">Create a host using `coreclrhost.h`</span></span>

<span data-ttu-id="c932a-150">As etapas a seguir detalham como usar a `coreclrhost.h` API para iniciar o tempo de execução do .NET Core em um aplicativo nativo e chamar um método estático gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-150">The following steps detail how to use the `coreclrhost.h` API to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="c932a-151">Os snippets de código neste documento usam algumas APIs específicas do Windows, mas o [host de exemplo completo](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) mostra os caminhos de código do Windows e do Linux.</span><span class="sxs-lookup"><span data-stu-id="c932a-151">The code snippets in this document use some Windows-specific APIs, but the [full sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) shows both Windows and Linux code paths.</span></span>

<span data-ttu-id="c932a-152">O [host Coexecutar UNIX](https://github.com/dotnet/runtime/tree/master/src/coreclr/hosts/unixcorerun) mostra um exemplo real mais complexo de hospedagem usando `coreclrhost.h` .</span><span class="sxs-lookup"><span data-stu-id="c932a-152">The [Unix CoreRun host](https://github.com/dotnet/runtime/tree/master/src/coreclr/hosts/unixcorerun) shows a more complex, real-world example of hosting using `coreclrhost.h`.</span></span>

### <a name="step-1---find-and-load-coreclr"></a><span data-ttu-id="c932a-153">Etapa 1 – Localizar e carregar a CoreCLR</span><span class="sxs-lookup"><span data-stu-id="c932a-153">Step 1 - Find and load CoreCLR</span></span>

<span data-ttu-id="c932a-154">As APIs de runtime do .NET Core estão em *coreclr.dll* (no Windows), em *libcoreclr.so* (no Linux) ou em *libcoreclr.dylib* (no macOS).</span><span class="sxs-lookup"><span data-stu-id="c932a-154">The .NET Core runtime APIs are in *coreclr.dll* (on Windows), in *libcoreclr.so* (on Linux), or in *libcoreclr.dylib* (on macOS).</span></span> <span data-ttu-id="c932a-155">A primeira etapa para hospedar o .NET Core é carregar a biblioteca do CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="c932a-155">The first step to hosting .NET Core is to load the CoreCLR library.</span></span> <span data-ttu-id="c932a-156">Alguns hosts investigam diferentes caminhos ou usam parâmetros de entrada para localizar a biblioteca, enquanto outros sabem carregá-la de um determinado caminho (por exemplo, próximo ao host ou de um local geral no computador).</span><span class="sxs-lookup"><span data-stu-id="c932a-156">Some hosts probe different paths or use input parameters to find the library while others know to load it from a certain path (next to the host, for example, or from a machine-wide location).</span></span>

<span data-ttu-id="c932a-157">Depois de encontrada, a biblioteca é carregada com `LoadLibraryEx` (no Windows) ou `dlopen` (no linux/MacOS).</span><span class="sxs-lookup"><span data-stu-id="c932a-157">Once found, the library is loaded with `LoadLibraryEx` (on Windows) or `dlopen` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#1](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#1)]

### <a name="step-2---get-net-core-hosting-functions"></a><span data-ttu-id="c932a-158">Etapa 2: Obter funções de hospedagem do .NET Core</span><span class="sxs-lookup"><span data-stu-id="c932a-158">Step 2 - Get .NET Core hosting functions</span></span>

<span data-ttu-id="c932a-159">A CoreClrHost tem vários métodos importantes úteis para a hospedagem do .NET Core:</span><span class="sxs-lookup"><span data-stu-id="c932a-159">CoreClrHost has several important methods useful for hosting .NET Core:</span></span>

* <span data-ttu-id="c932a-160">`coreclr_initialize`: Inicia o tempo de execução do .NET Core e configura o AppDomain (e somente) padrão.</span><span class="sxs-lookup"><span data-stu-id="c932a-160">`coreclr_initialize`: Starts the .NET Core runtime and sets up the default (and only) AppDomain.</span></span>
* <span data-ttu-id="c932a-161">`coreclr_execute_assembly`: Executa um assembly gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-161">`coreclr_execute_assembly`: Executes a managed assembly.</span></span>
* <span data-ttu-id="c932a-162">`coreclr_create_delegate`: Cria um ponteiro de função para um método gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-162">`coreclr_create_delegate`: Creates a function pointer to a managed method.</span></span>
* <span data-ttu-id="c932a-163">`coreclr_shutdown`: Desliga o tempo de execução do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="c932a-163">`coreclr_shutdown`: Shuts down the .NET Core runtime.</span></span>
* <span data-ttu-id="c932a-164">`coreclr_shutdown_2`: Like `coreclr_shutdown` , mas também recupera o código de saída do código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-164">`coreclr_shutdown_2`: Like `coreclr_shutdown`, but also retrieves the managed code's exit code.</span></span>

<span data-ttu-id="c932a-165">Depois de carregar a biblioteca do CoreCLR, a próxima etapa é obter referências a essas funções usando `GetProcAddress` (no Windows) ou `dlsym` (no linux/MacOS).</span><span class="sxs-lookup"><span data-stu-id="c932a-165">After loading the CoreCLR library, the next step is to get references to these functions using `GetProcAddress` (on Windows) or `dlsym` (on Linux/macOS).</span></span>

[!code-cpp[CoreClrHost#2](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#2)]

### <a name="step-3---prepare-runtime-properties"></a><span data-ttu-id="c932a-166">Etapa 3 – Preparar as propriedades do runtime</span><span class="sxs-lookup"><span data-stu-id="c932a-166">Step 3 - Prepare runtime properties</span></span>

<span data-ttu-id="c932a-167">Antes de iniciar o runtime, é necessário preparar algumas propriedades para especificar o comportamento (especialmente em relação ao carregador de assembly).</span><span class="sxs-lookup"><span data-stu-id="c932a-167">Before starting the runtime, it is necessary to prepare some properties to specify behavior (especially concerning the assembly loader).</span></span>

<span data-ttu-id="c932a-168">As propriedades comuns incluem:</span><span class="sxs-lookup"><span data-stu-id="c932a-168">Common properties include:</span></span>

* <span data-ttu-id="c932a-169">`TRUSTED_PLATFORM_ASSEMBLIES` Essa é uma lista de caminhos de assembly (delimitada por ";" no Windows e por ":" no Linux) que o runtime poderá resolver por padrão.</span><span class="sxs-lookup"><span data-stu-id="c932a-169">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Linux) which the runtime will be able to resolve by default.</span></span> <span data-ttu-id="c932a-170">Alguns hosts têm manifestos embutidos em código que listam os assemblies que eles podem carregar.</span><span class="sxs-lookup"><span data-stu-id="c932a-170">Some hosts have hard-coded manifests listing assemblies they can load.</span></span> <span data-ttu-id="c932a-171">Outros usuários colocarão uma biblioteca em determinados locais (próximos a *coreclr.dll*, por exemplo) nessa lista.</span><span class="sxs-lookup"><span data-stu-id="c932a-171">Others will put any library in certain locations (next to *coreclr.dll*, for example) on this list.</span></span>
* <span data-ttu-id="c932a-172">`APP_PATHS` Essa é uma lista de caminhos a serem investigados quanto a um assembly se ele não for encontrado na lista de TPA (assemblies de plataforma confiáveis).</span><span class="sxs-lookup"><span data-stu-id="c932a-172">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="c932a-173">Como o host tem mais controle sobre quais assemblies são carregados usando a lista de TPA, uma prática recomendada para hosts é determinar quais assemblies eles esperam carregar e listá-los explicitamente.</span><span class="sxs-lookup"><span data-stu-id="c932a-173">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="c932a-174">No entanto, se a investigação em tempo de execução for necessária, essa propriedade poderá habilitar esse cenário.</span><span class="sxs-lookup"><span data-stu-id="c932a-174">If probing at run time is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="c932a-175">`APP_NI_PATHS` Essa lista é semelhante à APP_PATHS, exceto que ela foi projetada para conter os caminhos que serão investigados para imagens nativas.</span><span class="sxs-lookup"><span data-stu-id="c932a-175">`APP_NI_PATHS` This list is similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="c932a-176">`NATIVE_DLL_SEARCH_DIRECTORIES` Essa propriedade é uma lista de caminhos que o carregador deverá investigar ao procurar bibliotecas nativas chamadas por meio de p/invoke.</span><span class="sxs-lookup"><span data-stu-id="c932a-176">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native libraries called via p/invoke.</span></span>
* <span data-ttu-id="c932a-177">`PLATFORM_RESOURCE_ROOTS` Essa lista inclui caminhos para investigação para assemblies de satélite de recursos (em subdiretórios específicos de cultura).</span><span class="sxs-lookup"><span data-stu-id="c932a-177">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific subdirectories).</span></span>

<span data-ttu-id="c932a-178">Neste host de exemplo, a lista de TPA é construída simplesmente listando todas as bibliotecas no diretório atual:</span><span class="sxs-lookup"><span data-stu-id="c932a-178">In this sample host, the TPA list is constructed by simply listing all libraries in the current directory:</span></span>

[!code-cpp[CoreClrHost#7](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#7)]

<span data-ttu-id="c932a-179">Como o exemplo é simples, ele só precisa da propriedade `TRUSTED_PLATFORM_ASSEMBLIES`:</span><span class="sxs-lookup"><span data-stu-id="c932a-179">Because the sample is simple, it only needs the `TRUSTED_PLATFORM_ASSEMBLIES` property:</span></span>

[!code-cpp[CoreClrHost#3](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#3)]

### <a name="step-4---start-the-runtime"></a><span data-ttu-id="c932a-180">Etapa 4 – Iniciar o runtime</span><span class="sxs-lookup"><span data-stu-id="c932a-180">Step 4 - Start the runtime</span></span>

<span data-ttu-id="c932a-181">`coreclrhost.h` As APIs iniciam o tempo de execução e criam o AppDomain padrão todos com uma única chamada.</span><span class="sxs-lookup"><span data-stu-id="c932a-181">`coreclrhost.h` APIs start the runtime and create the default AppDomain all with a single call.</span></span> <span data-ttu-id="c932a-182">A função `coreclr_initialize` usa um caminho base, um nome e as propriedades já descritas e retorna um identificador ao host por meio do parâmetro `hostHandle`.</span><span class="sxs-lookup"><span data-stu-id="c932a-182">The `coreclr_initialize` function takes a base path, name, and the properties described earlier and returns back a handle to the host via the `hostHandle` parameter.</span></span>

[!code-cpp[CoreClrHost#4](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#4)]

### <a name="step-5---run-managed-code"></a><span data-ttu-id="c932a-183">Etapa 5: Executar o código gerenciado</span><span class="sxs-lookup"><span data-stu-id="c932a-183">Step 5 - Run managed code!</span></span>

<span data-ttu-id="c932a-184">Com o runtime iniciado, o host pode chamar o código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-184">With the runtime started, the host can call managed code.</span></span> <span data-ttu-id="c932a-185">Isso pode ser feito de duas maneiras diferentes.</span><span class="sxs-lookup"><span data-stu-id="c932a-185">This can be done in a couple of different ways.</span></span> <span data-ttu-id="c932a-186">O código de exemplo vinculado a este tutorial usa a função `coreclr_create_delegate` para criar um delegado para um método estático gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-186">The sample code linked to this tutorial uses the `coreclr_create_delegate` function to create a delegate to a static managed method.</span></span> <span data-ttu-id="c932a-187">Essa API usa o [nome do assembly](../../standard/assembly/names.md), o nome de tipo qualificado pelo namespace e o nome do método como entradas e retorna um delegado que pode ser usado para invocar o método.</span><span class="sxs-lookup"><span data-stu-id="c932a-187">This API takes the [assembly name](../../standard/assembly/names.md), namespace-qualified type name, and method name as inputs and returns a delegate that can be used to invoke the method.</span></span>

[!code-cpp[CoreClrHost#5](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#5)]

<span data-ttu-id="c932a-188">Neste exemplo, agora o host pode chamar `managedDelegate` para executar o método `ManagedWorker.DoWork`.</span><span class="sxs-lookup"><span data-stu-id="c932a-188">In this sample, the host can now call `managedDelegate` to run the `ManagedWorker.DoWork` method.</span></span>

<span data-ttu-id="c932a-189">Como alternativa, a função `coreclr_execute_assembly` pode ser usada para iniciar um executável gerenciado.</span><span class="sxs-lookup"><span data-stu-id="c932a-189">Alternatively, the `coreclr_execute_assembly` function can be used to launch a managed executable.</span></span> <span data-ttu-id="c932a-190">Essa API usa um caminho de assembly e a matriz de argumentos como parâmetros de entrada.</span><span class="sxs-lookup"><span data-stu-id="c932a-190">This API takes an assembly path and array of arguments as input parameters.</span></span> <span data-ttu-id="c932a-191">Ela carrega o assembly nesse caminho e invoca seu método principal.</span><span class="sxs-lookup"><span data-stu-id="c932a-191">It loads the assembly at that path and invokes its main method.</span></span>

```c++
int hr = executeAssembly(
        hostHandle,
        domainId,
        argumentCount,
        arguments,
        "HelloWorld.exe",
        (unsigned int*)&exitCode);
```

### <a name="step-6---shutdown-and-clean-up"></a><span data-ttu-id="c932a-192">Etapa 6 – Desligamento e limpeza</span><span class="sxs-lookup"><span data-stu-id="c932a-192">Step 6 - Shutdown and clean up</span></span>

<span data-ttu-id="c932a-193">Por fim, quando o host concluir a execução do código gerenciado, o runtime do .NET Core será desligado com `coreclr_shutdown` ou `coreclr_shutdown_2`.</span><span class="sxs-lookup"><span data-stu-id="c932a-193">Finally, when the host is done running managed code, the .NET Core runtime is shut down with `coreclr_shutdown` or `coreclr_shutdown_2`.</span></span>

[!code-cpp[CoreClrHost#6](~/samples/snippets/core/tutorials/netcore-hosting/csharp/HostWithCoreClrHost/src/SampleHost.cpp#6)]

<span data-ttu-id="c932a-194">O CoreCLR não oferece suporte à reinicialização ou descarregamento.</span><span class="sxs-lookup"><span data-stu-id="c932a-194">CoreCLR does not support reinitialization or unloading.</span></span> <span data-ttu-id="c932a-195">Não chame `coreclr_initialize` novamente ou descarregue a biblioteca CoreCLR.</span><span class="sxs-lookup"><span data-stu-id="c932a-195">Do not call `coreclr_initialize` again or unload the CoreCLR library.</span></span>

## <a name="conclusion"></a><span data-ttu-id="c932a-196">Conclusão</span><span class="sxs-lookup"><span data-stu-id="c932a-196">Conclusion</span></span>

<span data-ttu-id="c932a-197">Depois que o host for criado, ele poderá ser testado executando-o na linha de comando e passando os argumentos esperados pelo host.</span><span class="sxs-lookup"><span data-stu-id="c932a-197">Once your host is built, it can be tested by running it from the command line and passing any arguments the host expects.</span></span> <span data-ttu-id="c932a-198">Ao especificar o aplicativo .NET Core a ser executado pelo host, lembre-se de usar o arquivo .dll produzido por `dotnet build`.</span><span class="sxs-lookup"><span data-stu-id="c932a-198">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="c932a-199">Os executáveis (arquivos .exe) produzidos por `dotnet publish` para aplicativos autossuficientes são, na verdade, o host padrão do .NET Core (para que o aplicativo possa ser iniciado diretamente na linha de comando nos principais cenários). O código de usuário é compilado em uma dll com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="c932a-199">Executables (.exe files) produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span>

<span data-ttu-id="c932a-200">Se as coisas não funcionarem inicialmente, verifique se *coreclr.dll* está disponível no local esperado pelo host, se todas as bibliotecas de estrutura necessárias estão na lista TPA e se o bit de bits do CoreCLR (32 bits ou 64 bits) corresponde à forma como o host foi criado.</span><span class="sxs-lookup"><span data-stu-id="c932a-200">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32-bit or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="c932a-201">A hospedagem do runtime do .NET Core é um cenário avançado do qual muitos desenvolvedores não precisarão. No entanto, para aqueles que precisam inicializar o código gerenciado de um processo nativo ou que precisam de mais controle sobre o comportamento do runtime do .NET Core, ela pode ser muito útil.</span><span class="sxs-lookup"><span data-stu-id="c932a-201">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span>
