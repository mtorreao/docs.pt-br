---
title: EventCounters no .NET Core
description: Neste artigo, você aprenderá o que é o EventCounters, como implementá-los e como consumi-los.
ms.date: 08/07/2020
ms.openlocfilehash: 08180b5580d2e7fe782fbd531a26872715825cdf
ms.sourcegitcommit: 4b79862c5b41fbd86cf38f926f6a49516059f6f2
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/18/2020
ms.locfileid: "97678205"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="75f32-103">EventCounters no .NET Core</span><span class="sxs-lookup"><span data-stu-id="75f32-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="75f32-104">**Este artigo aplica-se a: ✔️** SDK do .net Core 3,0 e versões posteriores</span><span class="sxs-lookup"><span data-stu-id="75f32-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="75f32-105">EventCounters são APIs do .NET Core usadas para coleta de métrica de desempenho leve, de plataforma cruzada e quase em tempo real.</span><span class="sxs-lookup"><span data-stu-id="75f32-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="75f32-106">EventCounters foram adicionados como uma alternativa de plataforma cruzada aos "contadores de desempenho" do .NET Framework no Windows.</span><span class="sxs-lookup"><span data-stu-id="75f32-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="75f32-107">Neste artigo, você aprenderá o que são os EventCounters, como implementá-los e como consumi-los.</span><span class="sxs-lookup"><span data-stu-id="75f32-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="75f32-108">O tempo de execução do .NET Core e algumas bibliotecas .NET publicam informações básicas de diagnóstico usando EventCounters a partir do .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="75f32-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="75f32-109">Além dos EventCounters que são fornecidos pelo tempo de execução do .NET, você pode optar por implementar seu próprio EventCounters.</span><span class="sxs-lookup"><span data-stu-id="75f32-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="75f32-110">EventCounters pode ser usado para controlar várias métricas.</span><span class="sxs-lookup"><span data-stu-id="75f32-110">EventCounters can be used to track various metrics.</span></span> <span data-ttu-id="75f32-111">Saiba mais sobre eles no [EventCounters bem conhecido no .net](available-counters.md)</span><span class="sxs-lookup"><span data-stu-id="75f32-111">Learn more about them in the [well-known EventCounters in .NET](available-counters.md)</span></span>

<span data-ttu-id="75f32-112">EventCounters em tempo real como parte de um <xref:System.Diagnostics.Tracing.EventSource> e são automaticamente enviados para ferramentas de ouvinte regularmente.</span><span class="sxs-lookup"><span data-stu-id="75f32-112">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="75f32-113">Assim como todos os outros eventos em um <xref:System.Diagnostics.Tracing.EventSource> , eles podem ser consumidos tanto no processo quanto fora do processo por meio de <xref:System.Diagnostics.Tracing.EventListener> e [EventPipe](./eventpipe.md).</span><span class="sxs-lookup"><span data-stu-id="75f32-113">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and [EventPipe](./eventpipe.md).</span></span> <span data-ttu-id="75f32-114">Este artigo se concentra nos recursos de plataforma cruzada do EventCounters e exclui intencionalmente o PerfView e o ETW (rastreamento de eventos para Windows) – embora ambos possam ser usados com o EventCounters.</span><span class="sxs-lookup"><span data-stu-id="75f32-114">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Imagem do diagrama EventCounters no proc e fora do processo](media/event-counters.svg)

## <a name="eventcounter-api-overview"></a><span data-ttu-id="75f32-116">Visão geral da API do EventCounter</span><span class="sxs-lookup"><span data-stu-id="75f32-116">EventCounter API overview</span></span>

<span data-ttu-id="75f32-117">Há duas categorias principais de contadores.</span><span class="sxs-lookup"><span data-stu-id="75f32-117">There are two primary categories of counters.</span></span> <span data-ttu-id="75f32-118">Alguns contadores são para valores de "taxa", como o número total de exceções, o número total de GCs e o número total de solicitações.</span><span class="sxs-lookup"><span data-stu-id="75f32-118">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="75f32-119">Outros contadores são valores de "instantâneo", como uso de heap, uso de CPU e tamanho de conjunto de trabalho.</span><span class="sxs-lookup"><span data-stu-id="75f32-119">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="75f32-120">Dentro de cada uma dessas categorias de contadores, há dois tipos de contadores que variam de acordo com o modo como eles obtêm seu valor.</span><span class="sxs-lookup"><span data-stu-id="75f32-120">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="75f32-121">Os contadores de sondagem recuperam seu valor por meio de um retorno de chamada, e os contadores de não sondagem têm seus valores definidos diretamente na instância do contador.</span><span class="sxs-lookup"><span data-stu-id="75f32-121">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="75f32-122">Os contadores são representados pelas seguintes implementações:</span><span class="sxs-lookup"><span data-stu-id="75f32-122">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="75f32-123">Um ouvinte de eventos especifica por quanto tempo os intervalos de medição são.</span><span class="sxs-lookup"><span data-stu-id="75f32-123">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="75f32-124">Ao final de cada intervalo, um valor é transmitido para o ouvinte para cada contador.</span><span class="sxs-lookup"><span data-stu-id="75f32-124">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="75f32-125">As implementações de um contador determinam quais APIs e cálculos são usados para produzir o valor em cada intervalo.</span><span class="sxs-lookup"><span data-stu-id="75f32-125">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="75f32-126">O <xref:System.Diagnostics.Tracing.EventCounter> registra um conjunto de valores.</span><span class="sxs-lookup"><span data-stu-id="75f32-126">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="75f32-127">O <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> método adiciona um novo valor ao conjunto.</span><span class="sxs-lookup"><span data-stu-id="75f32-127">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="75f32-128">Com cada intervalo, um resumo estatístico do conjunto é calculado, como mín., máx. e média.</span><span class="sxs-lookup"><span data-stu-id="75f32-128">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="75f32-129">A ferramenta [dotnet-Counters](dotnet-counters.md) sempre exibirá o valor médio.</span><span class="sxs-lookup"><span data-stu-id="75f32-129">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="75f32-130">O <xref:System.Diagnostics.Tracing.EventCounter> é útil para descrever um conjunto discreto de operações.</span><span class="sxs-lookup"><span data-stu-id="75f32-130">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="75f32-131">O uso comum pode incluir o monitoramento do tamanho médio em bytes de operações de e/s recentes ou o valor monetário médio de um conjunto de transações financeiras.</span><span class="sxs-lookup"><span data-stu-id="75f32-131">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="75f32-132"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Registra um total acumulado para cada intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="75f32-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="75f32-133">O <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> método adiciona ao total.</span><span class="sxs-lookup"><span data-stu-id="75f32-133">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="75f32-134">Por exemplo, se `Increment()` for chamado três vezes durante um intervalo com valores `1` , `2` e `5` , o total acumulado de `8` será relatado como o valor do contador para esse intervalo.</span><span class="sxs-lookup"><span data-stu-id="75f32-134">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="75f32-135">A ferramenta [dotnet-Counters](dotnet-counters.md) exibirá a taxa como o total/tempo gravado.</span><span class="sxs-lookup"><span data-stu-id="75f32-135">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="75f32-136">O <xref:System.Diagnostics.Tracing.IncrementingEventCounter> é útil para medir a frequência de ocorrência de uma ação, como o número de solicitações processadas por segundo.</span><span class="sxs-lookup"><span data-stu-id="75f32-136">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="75f32-137">O <xref:System.Diagnostics.Tracing.PollingCounter> usa um retorno de chamada para determinar o valor que é relatado.</span><span class="sxs-lookup"><span data-stu-id="75f32-137">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="75f32-138">Com cada intervalo de tempo, a função de retorno de chamada fornecida pelo usuário é invocada e o valor de retorno é usado como o valor do contador.</span><span class="sxs-lookup"><span data-stu-id="75f32-138">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="75f32-139">Um <xref:System.Diagnostics.Tracing.PollingCounter> pode ser usado para consultar uma métrica de uma fonte externa, por exemplo, obter os bytes livres atuais em um disco.</span><span class="sxs-lookup"><span data-stu-id="75f32-139">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="75f32-140">Ele também pode ser usado para relatar estatísticas personalizadas que podem ser computadas sob demanda por um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="75f32-140">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="75f32-141">Os exemplos incluem relatar o 95 º percentil de latências de solicitação recentes ou a taxa atual de acertos ou de erros de um cache.</span><span class="sxs-lookup"><span data-stu-id="75f32-141">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="75f32-142">O <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> usa um retorno de chamada para determinar o valor de incremento relatado.</span><span class="sxs-lookup"><span data-stu-id="75f32-142">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="75f32-143">Com cada intervalo de tempo, o retorno de chamada é invocado e, em seguida, a diferença entre a invocação atual e a última invocação é o valor relatado.</span><span class="sxs-lookup"><span data-stu-id="75f32-143">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="75f32-144">A ferramenta [dotnet-Counters](dotnet-counters.md) sempre exibirá a diferença como uma taxa, o valor/tempo relatado.</span><span class="sxs-lookup"><span data-stu-id="75f32-144">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="75f32-145">Esse contador é útil quando não é viável chamar uma API em cada ocorrência, mas é possível consultar o número total de ocorrências.</span><span class="sxs-lookup"><span data-stu-id="75f32-145">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="75f32-146">Por exemplo, você pode relatar o número de bytes gravados em um arquivo por segundo, mesmo sem uma notificação toda vez que um byte é gravado.</span><span class="sxs-lookup"><span data-stu-id="75f32-146">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="75f32-147">Implementar um EventSource</span><span class="sxs-lookup"><span data-stu-id="75f32-147">Implement an EventSource</span></span>

<span data-ttu-id="75f32-148">O código a seguir implementa um exemplo <xref:System.Diagnostics.Tracing.EventSource> exposto como o `"Sample.EventCounter.Minimal"` provedor nomeado.</span><span class="sxs-lookup"><span data-stu-id="75f32-148">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="75f32-149">Essa origem contém um <xref:System.Diagnostics.Tracing.EventCounter> tempo de processamento de solicitação de representação.</span><span class="sxs-lookup"><span data-stu-id="75f32-149">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="75f32-150">Esse contador tem um nome (ou seja, sua ID exclusiva na origem) e um nome de exibição, ambos usados por ferramentas de escuta, como [dotnet-Counter](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="75f32-150">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="75f32-151">Você usa `dotnet-counters ps` para exibir uma lista de processos .NET que podem ser monitorados:</span><span class="sxs-lookup"><span data-stu-id="75f32-151">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="75f32-152">Passe o <xref:System.Diagnostics.Tracing.EventSource> nome para a `--counters` opção de iniciar o monitoramento do seu contador:</span><span class="sxs-lookup"><span data-stu-id="75f32-152">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `--counters` option to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 --counters Sample.EventCounter.Minimal
```

<span data-ttu-id="75f32-153">O exemplo a seguir mostra a saída do monitor:</span><span class="sxs-lookup"><span data-stu-id="75f32-153">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="75f32-154">Pressione <kbd>q</kbd> para interromper o comando de monitoramento.</span><span class="sxs-lookup"><span data-stu-id="75f32-154">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="75f32-155">Contadores condicionais</span><span class="sxs-lookup"><span data-stu-id="75f32-155">Conditional counters</span></span>

<span data-ttu-id="75f32-156">Ao implementar um <xref:System.Diagnostics.Tracing.EventSource> , os contadores que os contêm podem ser instanciados condicionalmente quando o <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> método é chamado com um <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> valor de `EventCommand.Enable` .</span><span class="sxs-lookup"><span data-stu-id="75f32-156">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="75f32-157">Para instanciar com segurança uma instância de contador somente se for `null` , use o [operador de atribuição de União nula](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="75f32-157">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="75f32-158">Além disso, os métodos personalizados podem avaliar o <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> método para determinar se a origem do evento atual está habilitada ou não.</span><span class="sxs-lookup"><span data-stu-id="75f32-158">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="75f32-159">Os contadores condicionais são contadores que são condicionalmente instanciados, uma microotimização.</span><span class="sxs-lookup"><span data-stu-id="75f32-159">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="75f32-160">O tempo de execução adota esse padrão para cenários em que os contadores normalmente não são usados, para economizar uma fração de um milissegundo.</span><span class="sxs-lookup"><span data-stu-id="75f32-160">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="75f32-161">Contadores de exemplo de tempo de execução do .NET Core</span><span class="sxs-lookup"><span data-stu-id="75f32-161">.NET Core runtime example counters</span></span>

<span data-ttu-id="75f32-162">Há muitas excelentes implementações de exemplo no tempo de execução do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="75f32-162">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="75f32-163">Aqui está a implementação de tempo de execução para o contador que controla o tamanho do conjunto de trabalho do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="75f32-163">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="75f32-164">O <xref:System.Diagnostics.Tracing.PollingCounter> relata a quantidade atual de memória física mapeada para o processo (conjunto de trabalho) do aplicativo, já que ele captura uma métrica em um momento no tempo.</span><span class="sxs-lookup"><span data-stu-id="75f32-164">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="75f32-165">O retorno de chamada para sondar um valor é a expressão lambda fornecida, que é apenas uma chamada para a <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span><span class="sxs-lookup"><span data-stu-id="75f32-165">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="75f32-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> e <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> são propriedades opcionais que podem ser definidas para ajudar o lado do consumidor do contador a exibir o valor mais claramente.</span><span class="sxs-lookup"><span data-stu-id="75f32-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="75f32-167">Por exemplo, [dotnet-Counters](dotnet-counters.md) usa essas propriedades para exibir a versão mais amigável dos nomes dos contadores.</span><span class="sxs-lookup"><span data-stu-id="75f32-167">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="75f32-168">As `DisplayName` Propriedades não estão localizadas.</span><span class="sxs-lookup"><span data-stu-id="75f32-168">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="75f32-169">Para o <xref:System.Diagnostics.Tracing.PollingCounter> , e o <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> , nada mais precisa ser feito.</span><span class="sxs-lookup"><span data-stu-id="75f32-169">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="75f32-170">Ambos sondam os próprios valores em um intervalo solicitado pelo consumidor.</span><span class="sxs-lookup"><span data-stu-id="75f32-170">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="75f32-171">Aqui está um exemplo de um contador de tempo de execução implementado usando o <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> .</span><span class="sxs-lookup"><span data-stu-id="75f32-171">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="75f32-172">O <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> usa a <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API para relatar o incremento da contagem total de contenções de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="75f32-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="75f32-173">A <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> propriedade é opcional, mas quando usada, ela pode fornecer uma dica para qual intervalo de tempo o contador é exibido melhor.</span><span class="sxs-lookup"><span data-stu-id="75f32-173">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="75f32-174">Por exemplo, a contagem de contenções de bloqueio é melhor exibida como _contagem por segundo_, portanto, ela <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> é definida como um segundo.</span><span class="sxs-lookup"><span data-stu-id="75f32-174">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="75f32-175">A taxa de exibição pode ser ajustada para diferentes tipos de contadores de taxa.</span><span class="sxs-lookup"><span data-stu-id="75f32-175">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="75f32-176">O <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> _não_ é usado por [dotnet-Counters](dotnet-counters.md), e ouvintes de eventos não são obrigados a usá-lo.</span><span class="sxs-lookup"><span data-stu-id="75f32-176">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="75f32-177">Há mais implementações de contador a serem usadas como referência no repositório de [tempo de execução do .net](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) .</span><span class="sxs-lookup"><span data-stu-id="75f32-177">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="75f32-178">Simultaneidade</span><span class="sxs-lookup"><span data-stu-id="75f32-178">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="75f32-179">A API EventCounters não garante a segurança do thread.</span><span class="sxs-lookup"><span data-stu-id="75f32-179">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="75f32-180">Quando os delegados passados para <xref:System.Diagnostics.Tracing.PollingCounter> ou as <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instâncias são chamados por vários threads, é sua responsabilidade garantir a segurança de threads dos delegados.</span><span class="sxs-lookup"><span data-stu-id="75f32-180">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="75f32-181">Por exemplo, considere o seguinte <xref:System.Diagnostics.Tracing.EventSource> para acompanhar as solicitações.</span><span class="sxs-lookup"><span data-stu-id="75f32-181">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="75f32-182">O `AddRequest()` método pode ser chamado a partir de um manipulador de solicitação e o `RequestRateCounter` sonda o valor no intervalo especificado pelo consumidor do contador.</span><span class="sxs-lookup"><span data-stu-id="75f32-182">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="75f32-183">No entanto, o `AddRequest()` método pode ser chamado por vários threads de uma vez, colocando uma condição de corrida ativada `_requestCount` .</span><span class="sxs-lookup"><span data-stu-id="75f32-183">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="75f32-184">Uma maneira alternativa thread-safe de incrementar o `_requestCount` é usar <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="75f32-184">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

<span data-ttu-id="75f32-185">Para evitar leituras interrompidas (em arquiteturas de 32 bits) do `long` uso do `_requestCount` campo <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="75f32-185">To prevent torn reads (on 32-bit architectures) of the `long`-field `_requestCount` use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span></span>

```csharp
_requestRateCounter = new IncrementingPollingCounter("request-rate", this, () => Interlocked.Read(ref _requestCount))
{
    DisplayName = "Request Rate",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

## <a name="consume-eventcounters"></a><span data-ttu-id="75f32-186">Consumir EventCounters</span><span class="sxs-lookup"><span data-stu-id="75f32-186">Consume EventCounters</span></span>

<span data-ttu-id="75f32-187">Há duas maneiras principais de consumir EventCounters, seja no processo ou fora do processo.</span><span class="sxs-lookup"><span data-stu-id="75f32-187">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="75f32-188">O consumo de EventCounters pode ser diferenciado em três camadas de várias tecnologias consumidas.</span><span class="sxs-lookup"><span data-stu-id="75f32-188">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="75f32-189">Transportando eventos em um fluxo bruto via ETW ou EventPipe:</span><span class="sxs-lookup"><span data-stu-id="75f32-189">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="75f32-190">As APIs do ETW são fornecidas com o sistema operacional Windows, e o EventPipe é acessível como uma [API do .net](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console)ou o [protocolo IPC](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md)de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="75f32-190">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="75f32-191">Decodificando o fluxo de eventos binários em eventos:</span><span class="sxs-lookup"><span data-stu-id="75f32-191">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="75f32-192">A [biblioteca TraceEvent](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) lida com os formatos de fluxo ETW e EventPipe.</span><span class="sxs-lookup"><span data-stu-id="75f32-192">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="75f32-193">Ferramentas de linha de comando e GUI:</span><span class="sxs-lookup"><span data-stu-id="75f32-193">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="75f32-194">Ferramentas como PerfView (ETW ou EventPipe), dotnet-Counters (somente EventPipe) e dotnet-monitor (somente EventPipe).</span><span class="sxs-lookup"><span data-stu-id="75f32-194">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="75f32-195">Consumir fora do processo</span><span class="sxs-lookup"><span data-stu-id="75f32-195">Consume out-of-proc</span></span>

<span data-ttu-id="75f32-196">Consumir EventCounters fora do processo é uma abordagem muito comum.</span><span class="sxs-lookup"><span data-stu-id="75f32-196">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="75f32-197">Você pode usar os [contadores dotnet](dotnet-counters.md) para consumi-los em uma maneira de plataforma cruzada por meio de um EventPipe.</span><span class="sxs-lookup"><span data-stu-id="75f32-197">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="75f32-198">A `dotnet-counters` ferramenta é uma ferramenta global da CLI do dotNet de plataforma cruzada que pode ser usada para monitorar os valores do contador.</span><span class="sxs-lookup"><span data-stu-id="75f32-198">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="75f32-199">Para saber como usar o `dotnet-counters` para monitorar seus contadores, consulte [dotnet-Counters](dotnet-counters.md)ou trabalhe no tutorial [medir o desempenho usando o EventCounters](event-counter-perf.md) .</span><span class="sxs-lookup"><span data-stu-id="75f32-199">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="75f32-200">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="75f32-200">dotnet-trace</span></span>

<span data-ttu-id="75f32-201">A `dotnet-trace` ferramenta pode ser usada para consumir os dados do contador por meio de um EventPipe.</span><span class="sxs-lookup"><span data-stu-id="75f32-201">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="75f32-202">Aqui está um exemplo `dotnet-trace` de uso para coletar dados do contador.</span><span class="sxs-lookup"><span data-stu-id="75f32-202">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="75f32-203">Para obter mais informações sobre como coletar valores de contador ao longo do tempo, consulte a documentação do [rastreamento dotnet](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) .</span><span class="sxs-lookup"><span data-stu-id="75f32-203">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="75f32-204">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="75f32-204">Azure Application Insights</span></span>

<span data-ttu-id="75f32-205">O EventCounters pode ser consumido por Azure Monitor, especificamente Aplicativo Azure insights.</span><span class="sxs-lookup"><span data-stu-id="75f32-205">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="75f32-206">Os contadores podem ser adicionados e removidos, e você é livre para especificar contadores personalizados ou contadores conhecidos.</span><span class="sxs-lookup"><span data-stu-id="75f32-206">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="75f32-207">Para obter mais informações, consulte [Personalizando contadores a serem coletados](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="75f32-207">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="75f32-208">dotnet-monitor</span><span class="sxs-lookup"><span data-stu-id="75f32-208">dotnet-monitor</span></span>

<span data-ttu-id="75f32-209">A `dotnet-monitor` ferramenta é uma ferramenta experimental que torna mais fácil obter acesso a informações de diagnóstico em um processo do .net.</span><span class="sxs-lookup"><span data-stu-id="75f32-209">The `dotnet-monitor` tool is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="75f32-210">A ferramenta serve como um superconjunto de todas as ferramentas de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="75f32-210">The tool serves as a superset of all diagnostics tools.</span></span> <span data-ttu-id="75f32-211">Além dos rastreamentos, ele pode monitorar as métricas, coletar despejos de memória e coletar despejos de GC.</span><span class="sxs-lookup"><span data-stu-id="75f32-211">In addition to traces, it can monitor metrics, collect memory dumps, and collect GC dumps.</span></span> <span data-ttu-id="75f32-212">Ele é distribuído como uma ferramenta CLI e uma imagem do Docker.</span><span class="sxs-lookup"><span data-stu-id="75f32-212">It's distributed as both a CLI tool and a docker image.</span></span> <span data-ttu-id="75f32-213">Ele expõe uma API REST e a coleção de artefatos de diagnóstico ocorre por meio de chamadas REST.</span><span class="sxs-lookup"><span data-stu-id="75f32-213">It exposes a REST API, and the collection of diagnostic artifacts occurs through REST calls.</span></span>

<span data-ttu-id="75f32-214">Para obter mais informações, consulte [Introducing dotnet-monitor, uma ferramenta experimental](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="75f32-214">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="75f32-215">Consumir no processo</span><span class="sxs-lookup"><span data-stu-id="75f32-215">Consume in-proc</span></span>

<span data-ttu-id="75f32-216">Você pode consumir os valores do contador por meio da <xref:System.Diagnostics.Tracing.EventListener> API.</span><span class="sxs-lookup"><span data-stu-id="75f32-216">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="75f32-217">Um <xref:System.Diagnostics.Tracing.EventListener> é uma maneira no processo de consumir todos os eventos gravados por todas as instâncias de um <xref:System.Diagnostics.Tracing.EventSource> em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="75f32-217">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="75f32-218">Para obter mais informações sobre como usar a `EventListener` API, consulte <xref:System.Diagnostics.Tracing.EventListener> .</span><span class="sxs-lookup"><span data-stu-id="75f32-218">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="75f32-219">Primeiro, o <xref:System.Diagnostics.Tracing.EventSource> que produz o valor do contador precisa ser habilitado.</span><span class="sxs-lookup"><span data-stu-id="75f32-219">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="75f32-220">Substitua o <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> método para obter uma notificação quando um <xref:System.Diagnostics.Tracing.EventSource> for criado e, se esse for o correto <xref:System.Diagnostics.Tracing.EventSource> com seu EventCounters, você poderá chamá <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> -lo.</span><span class="sxs-lookup"><span data-stu-id="75f32-220">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="75f32-221">Aqui está um exemplo de substituição:</span><span class="sxs-lookup"><span data-stu-id="75f32-221">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="16-27":::

#### <a name="sample-code"></a><span data-ttu-id="75f32-222">Código de exemplo</span><span class="sxs-lookup"><span data-stu-id="75f32-222">Sample code</span></span>

<span data-ttu-id="75f32-223">Aqui está uma classe de exemplo <xref:System.Diagnostics.Tracing.EventListener> que imprime todos os nomes de contadores e valores de tempo de execução do .NET <xref:System.Diagnostics.Tracing.EventSource> , para publicar seus contadores internos ( `System.Runtime` ) em algum intervalo.</span><span class="sxs-lookup"><span data-stu-id="75f32-223">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) at some interval.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="75f32-224">Como mostrado acima, você _deve_ verificar se o `"EventCounterIntervalSec"` argumento está definido no `filterPayload` argumento ao chamar <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A> .</span><span class="sxs-lookup"><span data-stu-id="75f32-224">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="75f32-225">Caso contrário, os contadores não poderão liberar valores, já que ele não sabe em qual intervalo ele deve ser liberado.</span><span class="sxs-lookup"><span data-stu-id="75f32-225">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="75f32-226">Consulte também</span><span class="sxs-lookup"><span data-stu-id="75f32-226">See also</span></span>

- [<span data-ttu-id="75f32-227">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="75f32-227">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="75f32-228">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="75f32-228">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
