---
title: Regras de design (análise de código)
description: Saiba mais sobre as regras de design de análise de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8c7d46b9271e33ab7ce3f989fae95bd57394ccd
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/07/2020
ms.locfileid: "96585089"
---
# <a name="design-rules"></a><span data-ttu-id="69c5c-103">Regras de design</span><span class="sxs-lookup"><span data-stu-id="69c5c-103">Design rules</span></span>

<span data-ttu-id="69c5c-104">As regras de design dão suporte à adesão às [diretrizes de design de .NET Framework](../../../standard/design-guidelines/index.md).</span><span class="sxs-lookup"><span data-stu-id="69c5c-104">Design rules support adherence to the [.NET Framework Design Guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="69c5c-105">Nesta seção</span><span class="sxs-lookup"><span data-stu-id="69c5c-105">In this section</span></span>

| <span data-ttu-id="69c5c-106">Regra</span><span class="sxs-lookup"><span data-stu-id="69c5c-106">Rule</span></span> | <span data-ttu-id="69c5c-107">Descrição</span><span class="sxs-lookup"><span data-stu-id="69c5c-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="69c5c-108">CA1000: Não declarar membros estáticos em tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="69c5c-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="69c5c-109">Quando um membro estático de um tipo genérico é chamado, o argumento de tipo deve ser especificado para o tipo.</span><span class="sxs-lookup"><span data-stu-id="69c5c-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="69c5c-110">Quando um membro de instância genérico que não dá suporte à inferência é chamado, o argumento de tipo deve ser especificado para o membro.</span><span class="sxs-lookup"><span data-stu-id="69c5c-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="69c5c-111">Nesses dois casos, a sintaxe para especificar o argumento de tipo é diferente e facilmente confundida.</span><span class="sxs-lookup"><span data-stu-id="69c5c-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="69c5c-112">CA1001: Tipos com campos descartáveis devem ser descartáveis</span><span class="sxs-lookup"><span data-stu-id="69c5c-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="69c5c-113">Uma classe declara e implementa um campo de instância que é um tipo System. IDisposable e a classe não implementa IDisposable.</span><span class="sxs-lookup"><span data-stu-id="69c5c-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="69c5c-114">Uma classe que declara um campo IDisposable indiretamente possui um recurso não gerenciado e deve implementar a interface IDisposable.</span><span class="sxs-lookup"><span data-stu-id="69c5c-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="69c5c-115">CA1002: Não expor listas genéricas</span><span class="sxs-lookup"><span data-stu-id="69c5c-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="69c5c-116">System. Collections. Generic. List< (Of \<(T> ) >) é uma coleção genérica projetada para desempenho, não herança.</span><span class="sxs-lookup"><span data-stu-id="69c5c-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="69c5c-117">Por isso, List não contém membros virtuais.</span><span class="sxs-lookup"><span data-stu-id="69c5c-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="69c5c-118">As coleções genéricas projetadas para herança devem ser expostas em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="69c5c-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="69c5c-119">CA1003: Usar instâncias do manipulador de eventos genérico</span><span class="sxs-lookup"><span data-stu-id="69c5c-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="69c5c-120">Um tipo contém um delegado que retorna void, cuja assinatura contém dois parâmetros (o primeiro objeto e o segundo um tipo que pode ser atribuído a EventArgs) e o assembly de destinos que o contém .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="69c5c-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="69c5c-121">CA1005: Evitar parâmetros excessivos em tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="69c5c-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="69c5c-122">Quanto mais parâmetros de tipo um tipo genérico contiver, mais difícil será saber e lembrar-se do que cada parâmetro de tipo representa.</span><span class="sxs-lookup"><span data-stu-id="69c5c-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="69c5c-123">Normalmente, é óbvio com um parâmetro de tipo, como na lista \<T> e, em certos casos, com dois parâmetros de tipo, como no dicionário \<TKey, TValue> .</span><span class="sxs-lookup"><span data-stu-id="69c5c-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="69c5c-124">No entanto, se houver mais de dois parâmetros de tipo, a dificuldade ficará muito grande para a maioria dos usuários.</span><span class="sxs-lookup"><span data-stu-id="69c5c-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="69c5c-125">CA1008: Enumerações devem ter valor zero</span><span class="sxs-lookup"><span data-stu-id="69c5c-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="69c5c-126">O valor padrão de uma enumeração não inicializada, assim como o de outros tipos de valor, é zero.</span><span class="sxs-lookup"><span data-stu-id="69c5c-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="69c5c-127">Uma enumeração atribuída não sinalizações deve definir um membro usando o valor de zero para que o valor padrão seja um valor válido da enumeração.</span><span class="sxs-lookup"><span data-stu-id="69c5c-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="69c5c-128">Se uma enumeração que tem o atributo FlagsAttribute aplicado definir um membro com valor, seu nome deverá ser “None” para indicar que nenhum valor foi definido na enumeração.</span><span class="sxs-lookup"><span data-stu-id="69c5c-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="69c5c-129">CA1010: Coleções devem implementar uma interface genérica</span><span class="sxs-lookup"><span data-stu-id="69c5c-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="69c5c-130">Para ampliar a usabilidade de uma coleção, implemente uma das interfaces da coleção genéricas.</span><span class="sxs-lookup"><span data-stu-id="69c5c-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="69c5c-131">Em seguida, a coleção pode ser usada para popular tipos de coleção genéricos.</span><span class="sxs-lookup"><span data-stu-id="69c5c-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="69c5c-132">CA1012: Tipos abstratos não devem ter construtores</span><span class="sxs-lookup"><span data-stu-id="69c5c-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="69c5c-133">Construtores em tipos abstratos só podem ser chamados por tipos derivados.</span><span class="sxs-lookup"><span data-stu-id="69c5c-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="69c5c-134">Como construtores públicos criam instâncias de um tipo e não é possível criar instâncias de um tipo abstrato, um tipo abstrato com um construtor público é projetado incorretamente.</span><span class="sxs-lookup"><span data-stu-id="69c5c-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="69c5c-135">CA1014: Marcar assemblies com CLSCompliantAttribute</span><span class="sxs-lookup"><span data-stu-id="69c5c-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="69c5c-136">A CLS (Common Language Specification) define restrições de nomenclatura, tipos de dados e regras que assemblies deverão respeitar se forem usados em todas as linguagens de programação.</span><span class="sxs-lookup"><span data-stu-id="69c5c-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="69c5c-137">Um bom design dita que todos os assemblies indicam explicitamente a conformidade com CLS usando o CLSCompliantAttribute.</span><span class="sxs-lookup"><span data-stu-id="69c5c-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="69c5c-138">Se esse atributo não estiver presente em um assembly, o assembly não será compatível.</span><span class="sxs-lookup"><span data-stu-id="69c5c-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="69c5c-139">CA1016: Marcar assemblies com AssemblyVersionAttribute</span><span class="sxs-lookup"><span data-stu-id="69c5c-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="69c5c-140">O .NET usa o número de versão para identificar exclusivamente um assembly e para associar a tipos em assemblies com nomes de alta segurança.</span><span class="sxs-lookup"><span data-stu-id="69c5c-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="69c5c-141">O número de versão é usado com a versão e a política do publicador.</span><span class="sxs-lookup"><span data-stu-id="69c5c-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="69c5c-142">Por padrão, os aplicativos só são executados com a versão do assembly com que foram criados.</span><span class="sxs-lookup"><span data-stu-id="69c5c-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="69c5c-143">CA1017: Marcar assemblies com ComVisibleAttribute</span><span class="sxs-lookup"><span data-stu-id="69c5c-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="69c5c-144">ComVisibleAttribute determina como clientes COM acessam código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="69c5c-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="69c5c-145">Um bom design determina que os assemblies indiquem explicitamente a visibilidade de COM.</span><span class="sxs-lookup"><span data-stu-id="69c5c-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="69c5c-146">A visibilidade de COM pode ser definida para todo o assembly e, em seguida, substituída por tipos individuais e membros de tipo.</span><span class="sxs-lookup"><span data-stu-id="69c5c-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="69c5c-147">Caso esse atributo não esteja presente, o conteúdo do assembly permanece visível aos clientes COM.</span><span class="sxs-lookup"><span data-stu-id="69c5c-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="69c5c-148">CA1018: Marcar atributos com AttributeUsageAttribute</span><span class="sxs-lookup"><span data-stu-id="69c5c-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="69c5c-149">Ao definir um atributo personalizado, você o marca usando AttributeUsageAttribute para indicar onde o atributo personalizado pode ser aplicado no código-fonte.</span><span class="sxs-lookup"><span data-stu-id="69c5c-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="69c5c-150">O significado e o uso desejado de um atributo determinarão seus locais válidos no código.</span><span class="sxs-lookup"><span data-stu-id="69c5c-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="69c5c-151">CA1019: Definir acessadores para argumentos de atributo</span><span class="sxs-lookup"><span data-stu-id="69c5c-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="69c5c-152">Os atributos podem definir argumentos obrigatórios que devem ser especificados quando você aplica o atributo a um destino.</span><span class="sxs-lookup"><span data-stu-id="69c5c-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="69c5c-153">Eles também são conhecidos como argumentos posicionais porque são fornecidos a construtores de atributos como parâmetros posicionais.</span><span class="sxs-lookup"><span data-stu-id="69c5c-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="69c5c-154">Para cada argumento obrigatório, o atributo também deve fornecer uma propriedade somente leitura correspondente de forma que o valor do argumento possa ser recuperado no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="69c5c-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="69c5c-155">Os atributos também podem definir argumentos opcionais, que também são conhecidos como argumentos nomeados.</span><span class="sxs-lookup"><span data-stu-id="69c5c-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="69c5c-156">Esses argumentos são fornecidos a construtores de atributo por nome e devem ter uma propriedade de leitura/gravação correspondente.</span><span class="sxs-lookup"><span data-stu-id="69c5c-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="69c5c-157">CA1021: Evitar parâmetros out</span><span class="sxs-lookup"><span data-stu-id="69c5c-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="69c5c-158">A passagem de tipos por referência (usando out ou ref) requer experiência com ponteiros, compreensão das diferenças entre tipos de valor e tipos de referência e os métodos de tratamento com vários valores de retorno.</span><span class="sxs-lookup"><span data-stu-id="69c5c-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="69c5c-159">Além disso, a diferença entre parâmetros out e ref não é amplamente compreendida.</span><span class="sxs-lookup"><span data-stu-id="69c5c-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="69c5c-160">CA1024: Usar propriedades quando apropriado</span><span class="sxs-lookup"><span data-stu-id="69c5c-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="69c5c-161">Um método público ou protegido tem um nome que começa com "Get", não utiliza parâmetros e retorna um valor que não é uma matriz.</span><span class="sxs-lookup"><span data-stu-id="69c5c-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="69c5c-162">O método pode ser um bom candidato a se tornar uma propriedade.</span><span class="sxs-lookup"><span data-stu-id="69c5c-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="69c5c-163">CA1027: Marcar enumerações com FlagsAttribute</span><span class="sxs-lookup"><span data-stu-id="69c5c-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="69c5c-164">Uma enumeração é um tipo de valor que define um conjunto de constantes nomeadas relacionadas.</span><span class="sxs-lookup"><span data-stu-id="69c5c-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="69c5c-165">Aplique FlagsAttribute a uma enumeração quando suas constantes nomeadas puderem ser combinadas de maneira significativa.</span><span class="sxs-lookup"><span data-stu-id="69c5c-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="69c5c-166">CA1028: O armazenamento de enumerações deve ser Int32</span><span class="sxs-lookup"><span data-stu-id="69c5c-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="69c5c-167">Uma enumeração é um tipo de valor que define um conjunto de constantes nomeadas relacionadas.</span><span class="sxs-lookup"><span data-stu-id="69c5c-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="69c5c-168">Por padrão, o tipo de dados System.Int32 é usado para armazenar o valor constante.</span><span class="sxs-lookup"><span data-stu-id="69c5c-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="69c5c-169">Embora você possa alterar esse tipo subjacente, ele não é obrigatório ou recomendado para a maioria dos cenários.</span><span class="sxs-lookup"><span data-stu-id="69c5c-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="69c5c-170">CA1030: Usar eventos quando apropriado</span><span class="sxs-lookup"><span data-stu-id="69c5c-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="69c5c-171">Essa regra detecta métodos que têm nomes que seriam usados normalmente em eventos.</span><span class="sxs-lookup"><span data-stu-id="69c5c-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="69c5c-172">Se um método for chamado em resposta a uma alteração de estado claramente definida, o método deverá ser invocado por um manipulador de eventos.</span><span class="sxs-lookup"><span data-stu-id="69c5c-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="69c5c-173">Os objetos que chamam o método devem acionar eventos, em vez de chamar o método diretamente.</span><span class="sxs-lookup"><span data-stu-id="69c5c-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="69c5c-174">CA1031: Não capturar tipos de exceção geral</span><span class="sxs-lookup"><span data-stu-id="69c5c-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="69c5c-175">As exceções gerais não devem ser capturadas.</span><span class="sxs-lookup"><span data-stu-id="69c5c-175">General exceptions should not be caught.</span></span> <span data-ttu-id="69c5c-176">Pegue uma exceção mais específica ou relance a exceção geral como a última instrução no bloco catch.</span><span class="sxs-lookup"><span data-stu-id="69c5c-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="69c5c-177">CA1032: Implementar construtores de exceção padrão</span><span class="sxs-lookup"><span data-stu-id="69c5c-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="69c5c-178">Deixar de fornecer o conjunto completo de construtores pode dificultar o tratamento correto das exceções.</span><span class="sxs-lookup"><span data-stu-id="69c5c-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="69c5c-179">CA1033: Métodos de interface devem ser chamados por tipos filho</span><span class="sxs-lookup"><span data-stu-id="69c5c-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="69c5c-180">Um tipo visível externamente sem lacre fornece uma implementação de método explícita de uma interface pública e não fornece um método visível externamente alternativo com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="69c5c-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="69c5c-181">CA1034: Tipos aninhados não devem ser visíveis</span><span class="sxs-lookup"><span data-stu-id="69c5c-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="69c5c-182">Um tipo aninhado é um tipo declarado no escopo de outro tipo.</span><span class="sxs-lookup"><span data-stu-id="69c5c-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="69c5c-183">Os tipos aninhados são úteis para encapsular detalhes de implementação privados do tipo de contenção.</span><span class="sxs-lookup"><span data-stu-id="69c5c-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="69c5c-184">Usados para essa finalidade, os tipos aninhados não devem ser visíveis externamente.</span><span class="sxs-lookup"><span data-stu-id="69c5c-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="69c5c-185">CA1036: Substituir métodos em tipos comparáveis</span><span class="sxs-lookup"><span data-stu-id="69c5c-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="69c5c-186">Um público ou um tipo protegido implementa a interface System.IComparable.</span><span class="sxs-lookup"><span data-stu-id="69c5c-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="69c5c-187">Ele não substitui Object.Equals nem sobrecarrega o operador específico da linguagem para igualdade, desigualdade, menor que ou maior que.</span><span class="sxs-lookup"><span data-stu-id="69c5c-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="69c5c-188">CA1040: Evitar interfaces vazias</span><span class="sxs-lookup"><span data-stu-id="69c5c-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="69c5c-189">As interfaces definem os membros que fornecem um contrato de comportamento ou de uso.</span><span class="sxs-lookup"><span data-stu-id="69c5c-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="69c5c-190">A funcionalidade descrita pela interface pode ser adotada por qualquer tipo, independentemente de onde o tipo seja exibido na hierarquia de herança.</span><span class="sxs-lookup"><span data-stu-id="69c5c-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="69c5c-191">Um tipo implementa uma interface fornecendo implementações para os membros da interface.</span><span class="sxs-lookup"><span data-stu-id="69c5c-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="69c5c-192">Uma interface vazia não define membros; por isso, ela não define um contrato que pode ser implementado.</span><span class="sxs-lookup"><span data-stu-id="69c5c-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="69c5c-193">CA1041: Fornecer a mensagem ObsoleteAttribute</span><span class="sxs-lookup"><span data-stu-id="69c5c-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="69c5c-194">Um tipo ou um membro é marcado usando-se um atributo System.ObsoleteAttribute que não tem sua propriedade ObsoleteAttribute.Message especificada.</span><span class="sxs-lookup"><span data-stu-id="69c5c-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="69c5c-195">Quando um tipo ou membro que é marcado usando ObsoleteAttribute é compilado, a propriedade Message do atributo é exibida, o que fornece as informações do usuário sobre o tipo ou o membro obsoleto.</span><span class="sxs-lookup"><span data-stu-id="69c5c-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="69c5c-196">CA1043: Usar argumento integral ou de cadeia de caracteres para indexadores</span><span class="sxs-lookup"><span data-stu-id="69c5c-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="69c5c-197">Os indicadores (ou seja, propriedades indexadas) devem usar tipos integrais ou de cadeia de caracteres no índice.</span><span class="sxs-lookup"><span data-stu-id="69c5c-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="69c5c-198">Esses tipos normalmente são usados na indexação de estruturas de dados e aumentam a usabilidade da biblioteca.</span><span class="sxs-lookup"><span data-stu-id="69c5c-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="69c5c-199">O uso do tipo Object deve ser restrito a esses casos em que o tipo integral ou de cadeia de caracteres específico não pode ser especificado no tempo de design.</span><span class="sxs-lookup"><span data-stu-id="69c5c-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="69c5c-200">CA1044: Propriedades não devem ser somente gravação</span><span class="sxs-lookup"><span data-stu-id="69c5c-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="69c5c-201">Embora seja aceitável e normalmente necessário ter uma propriedade somente leitura, as diretrizes de design proíbem o uso de propriedades somente gravação.</span><span class="sxs-lookup"><span data-stu-id="69c5c-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="69c5c-202">Isso é porque a permissão para que um usuário defina um valor e o impedimento posterior para ele exiba esse valor não dão nenhuma segurança.</span><span class="sxs-lookup"><span data-stu-id="69c5c-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="69c5c-203">Além disso, sem acesso de leitura, o estado de objetos compartilhados não pode ser exibido, o que limita sua utilidade.</span><span class="sxs-lookup"><span data-stu-id="69c5c-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="69c5c-204">CA1045: Não passar tipos por referência</span><span class="sxs-lookup"><span data-stu-id="69c5c-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="69c5c-205">A passagem de tipos por referência (usando out ou ref) requer experiência com ponteiros, compreensão das diferenças entre tipos de valor e tipos de referência e os métodos de tratamento com vários valores de retorno.</span><span class="sxs-lookup"><span data-stu-id="69c5c-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="69c5c-206">Os arquitetos de bibliotecas que projetam para um público em geral não devem esperar que os usuários dominem o trabalho com parâmetros out ou ref.</span><span class="sxs-lookup"><span data-stu-id="69c5c-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="69c5c-207">CA1046: Não sobrecarregar o operador equals em tipos de referência</span><span class="sxs-lookup"><span data-stu-id="69c5c-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="69c5c-208">Para tipos de referência, a implementação padrão do operador de igualdade está quase sempre correta.</span><span class="sxs-lookup"><span data-stu-id="69c5c-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="69c5c-209">Por padrão, duas referências só serão iguais se apontarem para o mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="69c5c-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="69c5c-210">CA1047: Não declarar membros protegidos em tipos selados</span><span class="sxs-lookup"><span data-stu-id="69c5c-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="69c5c-211">Os tipos declaram membros protegidos de forma que a herança de tipos possa acessar ou substituir o membro.</span><span class="sxs-lookup"><span data-stu-id="69c5c-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="69c5c-212">Por definição, os tipos vedados não podem ser lacrados, o que significa que os métodos protegidos em tipos lacrados não podem ser chamados.</span><span class="sxs-lookup"><span data-stu-id="69c5c-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="69c5c-213">CA1050: Declarar tipos em namespaces</span><span class="sxs-lookup"><span data-stu-id="69c5c-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="69c5c-214">Tipos são declarados em namespaces para evitar conflitos de nome e são uma maneira de organizar tipos relacionados em uma hierarquia de objetos.</span><span class="sxs-lookup"><span data-stu-id="69c5c-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="69c5c-215">CA1051: Não declarar campos de instância visíveis</span><span class="sxs-lookup"><span data-stu-id="69c5c-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="69c5c-216">O principal uso de um campo deve ser um como um detalhe da implementação.</span><span class="sxs-lookup"><span data-stu-id="69c5c-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="69c5c-217">Os campos devem ser privados ou internos e devem ser expostos usando-se propriedades.</span><span class="sxs-lookup"><span data-stu-id="69c5c-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="69c5c-218">CA1052: Tipos de suporte estático devem ser selados</span><span class="sxs-lookup"><span data-stu-id="69c5c-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="69c5c-219">Um tipo público ou protegido contém apenas membros estáticos e não é declarado usando o modificador lacrado (C#) ou NotInheritable (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="69c5c-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="69c5c-220">Um tipo que não é deve ser herdado deve ser marcado usando-se o modificador lacrado para evitar seu uso como um tipo de base.</span><span class="sxs-lookup"><span data-stu-id="69c5c-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="69c5c-221">CA1053: Tipos de suporte estático não devem ter construtores</span><span class="sxs-lookup"><span data-stu-id="69c5c-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="69c5c-222">Um tipo público ou público aninhado declara apenas membros estáticos e tem um construtor padrão público ou protegido.</span><span class="sxs-lookup"><span data-stu-id="69c5c-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="69c5c-223">O construtor é desnecessário porque chamar membros estáticos não exige uma instância do tipo.</span><span class="sxs-lookup"><span data-stu-id="69c5c-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="69c5c-224">A sobrecarga de cadeia de caracteres deve chamar a sobrecarga do URI (Uniform Resource Identifier) usando-se o argumento de cadeia de caracteres por questões de segurança.</span><span class="sxs-lookup"><span data-stu-id="69c5c-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="69c5c-225">CA1054: Parâmetros de URI não devem ser cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="69c5c-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="69c5c-226">Se um método utilizar uma representação de cadeia de caracteres de um URI, uma sobrecarga correspondente deverá ser fornecida utilizando uma instância da classe do URI, que oferece esses serviços de maneira segura e protegida.</span><span class="sxs-lookup"><span data-stu-id="69c5c-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="69c5c-227">CA1055: Valores de retorno de URI não devem ser cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="69c5c-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="69c5c-228">Esta regra pressupõe que o método retorne um URI.</span><span class="sxs-lookup"><span data-stu-id="69c5c-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="69c5c-229">Uma representação de cadeia de caracteres de um URI está propensa a erros de análise e de codificação, e pode resultar em vulnerabilidades de segurança.</span><span class="sxs-lookup"><span data-stu-id="69c5c-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="69c5c-230">A classe System.Uri fornece esses serviços de maneira segura.</span><span class="sxs-lookup"><span data-stu-id="69c5c-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="69c5c-231">CA1056: Propriedades de URI não devem ser cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="69c5c-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="69c5c-232">Essa regra pressupõe que a propriedade representa um URI.</span><span class="sxs-lookup"><span data-stu-id="69c5c-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="69c5c-233">Uma representação de cadeia de caracteres de um URI está propensa a erros de análise e de codificação, e pode resultar em vulnerabilidades de segurança.</span><span class="sxs-lookup"><span data-stu-id="69c5c-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="69c5c-234">A classe System.Uri fornece esses serviços de maneira segura.</span><span class="sxs-lookup"><span data-stu-id="69c5c-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="69c5c-235">CA1058: Tipos não devem estender determinados tipos base</span><span class="sxs-lookup"><span data-stu-id="69c5c-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="69c5c-236">Um tipo visível externamente estende determinados tipos de base.</span><span class="sxs-lookup"><span data-stu-id="69c5c-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="69c5c-237">Use uma das alternativas.</span><span class="sxs-lookup"><span data-stu-id="69c5c-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="69c5c-238">CA1060: mover P/Invokes para a classe NativeMethods</span><span class="sxs-lookup"><span data-stu-id="69c5c-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="69c5c-239">Os métodos de invocação de plataforma, como aqueles marcados com os <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> métodos ou definidos usando a palavra-chave declare no Visual Basic, acessam o código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="69c5c-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="69c5c-240">Esses métodos devem ser da classe NativeMethods, SafeNativeMethods ou UnsafeNativeMethods.</span><span class="sxs-lookup"><span data-stu-id="69c5c-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="69c5c-241">CA1061: Não ocultar métodos de classe base</span><span class="sxs-lookup"><span data-stu-id="69c5c-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="69c5c-242">Um método em um tipo de base permanece oculto por um método nomeado identicamente em um tipo derivado, quando a assinatura do parâmetro do método derivado difere apenas pelos tipos derivados de maneira mais fraca do que os tipos correspondentes na assinatura do parâmetro do método de base.</span><span class="sxs-lookup"><span data-stu-id="69c5c-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="69c5c-243">CA1062: Validar argumentos de métodos públicos</span><span class="sxs-lookup"><span data-stu-id="69c5c-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="69c5c-244">Todos os argumentos de referência passados para os métodos visíveis externamente devem ser verificados em relação que serão nulos.</span><span class="sxs-lookup"><span data-stu-id="69c5c-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="69c5c-245">CA1063: Implementar IDisposable corretamente</span><span class="sxs-lookup"><span data-stu-id="69c5c-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="69c5c-246">Todos os tipos IDisposable devem implementar o padrão Dispose corretamente.</span><span class="sxs-lookup"><span data-stu-id="69c5c-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="69c5c-247">CA1064: Exceções devem ser públicas</span><span class="sxs-lookup"><span data-stu-id="69c5c-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="69c5c-248">Uma exceção interna só permanece visível dentro do próprio escopo interno.</span><span class="sxs-lookup"><span data-stu-id="69c5c-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="69c5c-249">Depois que a exceção falha fora do escopo interno, somente a exceção de base pode ser usada para capturar a exceção.</span><span class="sxs-lookup"><span data-stu-id="69c5c-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="69c5c-250">Se a exceção interna for herdada de <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> ou <xref:System.ApplicationException?displayProperty=fullName> , o código externo não terá informações suficientes para saber o que fazer com a exceção.</span><span class="sxs-lookup"><span data-stu-id="69c5c-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="69c5c-251">CA1065: Não acionar exceções em locais inesperados</span><span class="sxs-lookup"><span data-stu-id="69c5c-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="69c5c-252">Um método que não deve acionar exceções aciona uma exceção.</span><span class="sxs-lookup"><span data-stu-id="69c5c-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="69c5c-253">CA1066: Implementar IEquatable ao substituir Equals</span><span class="sxs-lookup"><span data-stu-id="69c5c-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="69c5c-254">Um tipo de valor substitui o <xref:System.Object.Equals%2A> método, mas não <xref:System.IEquatable%601> implementa.</span><span class="sxs-lookup"><span data-stu-id="69c5c-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="69c5c-255">CA1067: Substituir Equals ao implementar IEquatable</span><span class="sxs-lookup"><span data-stu-id="69c5c-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="69c5c-256">Um tipo implementa <xref:System.IEquatable%601> , mas não substitui o <xref:System.Object.Equals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="69c5c-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="69c5c-257">CA1068: Os parâmetros CancellationToken devem vir por último</span><span class="sxs-lookup"><span data-stu-id="69c5c-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="69c5c-258">Um método tem um parâmetro CancellationToken que não é o último parâmetro.</span><span class="sxs-lookup"><span data-stu-id="69c5c-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="69c5c-259">CA1069: Enumerações não devem ter valores duplicados</span><span class="sxs-lookup"><span data-stu-id="69c5c-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="69c5c-260">Uma enumeração tem vários membros que são atribuídos explicitamente ao mesmo valor de constante.</span><span class="sxs-lookup"><span data-stu-id="69c5c-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="69c5c-261">CA1070: Não declarar os campos de evento como virtuais</span><span class="sxs-lookup"><span data-stu-id="69c5c-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="69c5c-262">Um [evento do tipo campo](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) foi declarado como virtual.</span><span class="sxs-lookup"><span data-stu-id="69c5c-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
