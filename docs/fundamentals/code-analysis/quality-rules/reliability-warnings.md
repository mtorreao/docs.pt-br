---
title: Regras de confiabilidade (análise de código)
description: Saiba mais sobre as regras de confiabilidade da análise de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/07/2020
ms.locfileid: "96585090"
---
# <a name="reliability-rules"></a><span data-ttu-id="8b843-103">Regras de confiabilidade</span><span class="sxs-lookup"><span data-stu-id="8b843-103">Reliability rules</span></span>

<span data-ttu-id="8b843-104">As regras de confiabilidade dão suporte à confiabilidade de aplicativo e biblioteca, como a memória correta e o uso de thread.</span><span class="sxs-lookup"><span data-stu-id="8b843-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="8b843-105">As regras de confiabilidade incluem:</span><span class="sxs-lookup"><span data-stu-id="8b843-105">The reliability rules include:</span></span>

|<span data-ttu-id="8b843-106">Regra</span><span class="sxs-lookup"><span data-stu-id="8b843-106">Rule</span></span>|<span data-ttu-id="8b843-107">Descrição</span><span class="sxs-lookup"><span data-stu-id="8b843-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="8b843-108">CA2000: Descartar objetos antes de perder o escopo</span><span class="sxs-lookup"><span data-stu-id="8b843-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="8b843-109">Como pode ocorrer um evento excepcional que impedirá a execução do finalizador de um objeto, o objeto deve ser explicitamente descartado antes que todas as referências a ele estejam fora do escopo.</span><span class="sxs-lookup"><span data-stu-id="8b843-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="8b843-110">CA2002: Não bloquear objetos com identidade fraca</span><span class="sxs-lookup"><span data-stu-id="8b843-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="8b843-111">Diz-se que um objeto tem uma identidade fraca quando puder ser acessado diretamente em todos os limites de domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="8b843-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="8b843-112">Um thread que tente adquirir um bloqueio em um objeto com uma identidade fraca pode ser bloqueado por um segundo thread em um domínio de aplicativo diferente com um bloqueio no mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="8b843-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="8b843-113">CA2007: não aguardar diretamente uma tarefa</span><span class="sxs-lookup"><span data-stu-id="8b843-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="8b843-114">Um método assíncrono [aguarda](../../../csharp/language-reference/operators/await.md) um <xref:System.Threading.Tasks.Task> diretamente.</span><span class="sxs-lookup"><span data-stu-id="8b843-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="8b843-115">CA2008: Não criar tarefas sem passar um TaskScheduler</span><span class="sxs-lookup"><span data-stu-id="8b843-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="8b843-116">Uma operação de criação ou de continuação de tarefa usa uma sobrecarga de método que não especifica um <xref:System.Threading.Tasks.TaskScheduler> parâmetro.</span><span class="sxs-lookup"><span data-stu-id="8b843-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="8b843-117">CA2009: Não chamar ToImmutableCollection em um valor ImmutableCollection</span><span class="sxs-lookup"><span data-stu-id="8b843-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="8b843-118">`ToImmutable` o método não era necessariamente chamado em uma coleção imutável do <xref:System.Collections.Immutable> namespace.</span><span class="sxs-lookup"><span data-stu-id="8b843-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="8b843-119">CA2011: Não atribuir a propriedade em seu próprio setter</span><span class="sxs-lookup"><span data-stu-id="8b843-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="8b843-120">Uma propriedade recebeu acidentalmente um valor dentro de seu próprio [acessador set](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span><span class="sxs-lookup"><span data-stu-id="8b843-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="8b843-121">CA2012: Usar ValueTasks corretamente</span><span class="sxs-lookup"><span data-stu-id="8b843-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="8b843-122">ValueTasks retornados de invocações de membro devem ser diretamente aguardados.</span><span class="sxs-lookup"><span data-stu-id="8b843-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="8b843-123">Tenta consumir um ValueTask várias vezes ou para acessar diretamente um resultado antes que seja conhecido a ser concluído pode resultar em uma exceção ou corrupção.</span><span class="sxs-lookup"><span data-stu-id="8b843-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="8b843-124">Ignorar essa ValueTask é provavelmente uma indicação de um bug funcional e pode prejudicar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="8b843-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="8b843-125">CA2013: Não usar ReferenceEquals com tipos de valor</span><span class="sxs-lookup"><span data-stu-id="8b843-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="8b843-126">Ao comparar valores usando <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> , se objA e objB forem tipos de valor, eles estarão em caixa antes de serem passados para o <xref:System.Object.ReferenceEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="8b843-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="8b843-127">Isso significa que, mesmo que objA e objB representem a mesma instância de um tipo de valor, o método, no <xref:System.Object.ReferenceEquals%2A> entanto, retorna false.</span><span class="sxs-lookup"><span data-stu-id="8b843-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="8b843-128">CA2014: não use stackalloc em loops.</span><span class="sxs-lookup"><span data-stu-id="8b843-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="8b843-129">O espaço de pilha alocado por um stackalloc é liberado apenas no final da invocação do método atual.</span><span class="sxs-lookup"><span data-stu-id="8b843-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="8b843-130">Usá-lo em um loop pode resultar em aumento de pilha não associado e condições de estouro de pilha eventual.</span><span class="sxs-lookup"><span data-stu-id="8b843-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="8b843-131">CA2015: não definir finalizadores para tipos derivados de MemoryManager &lt; T&gt;</span><span class="sxs-lookup"><span data-stu-id="8b843-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="8b843-132">Adicionar um finalizador a um tipo derivado de <xref:System.Buffers.MemoryManager%601> pode permitir que a memória seja liberada enquanto ainda estiver em uso por um <xref:System.Span%601> .</span><span class="sxs-lookup"><span data-stu-id="8b843-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="8b843-133">CA2016: Encaminhe o parâmetro CancellationToken para os métodos que recebem um</span><span class="sxs-lookup"><span data-stu-id="8b843-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="8b843-134">Encaminhe o `CancellationToken` parâmetro para os métodos que usam um para garantir que as notificações de cancelamento da operação sejam propagadas corretamente ou repassem `CancellationToken.None` explicitamente para indicar, de forma intencional, não a propagação do token.</span><span class="sxs-lookup"><span data-stu-id="8b843-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
