---
title: Regras de desempenho (análise de código)
description: Saiba mais sobre as regras de desempenho da análise de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/25/2020
ms.locfileid: "96584724"
---
# <a name="performance-rules"></a><span data-ttu-id="ed1ea-103">Regras de desempenho</span><span class="sxs-lookup"><span data-stu-id="ed1ea-103">Performance rules</span></span>

<span data-ttu-id="ed1ea-104">As regras de desempenho dão suporte a bibliotecas e aplicativos de alto desempenho.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="ed1ea-105">Nesta seção</span><span class="sxs-lookup"><span data-stu-id="ed1ea-105">In this section</span></span>

| <span data-ttu-id="ed1ea-106">Regra</span><span class="sxs-lookup"><span data-stu-id="ed1ea-106">Rule</span></span> | <span data-ttu-id="ed1ea-107">Descrição</span><span class="sxs-lookup"><span data-stu-id="ed1ea-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="ed1ea-108">CA1802: Usar literais quando apropriado</span><span class="sxs-lookup"><span data-stu-id="ed1ea-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="ed1ea-109">Um campo é declarado estático e somente leitura (compartilhado e ReadOnly em Visual Basic) e é inicializado com um valor que é computáveis no momento da compilação.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="ed1ea-110">Como o valor atribuído ao campo de destino é computáveis em tempo de compilação, altere a declaração para um campo const (const no Visual Basic) para que o valor seja calculado em tempo de compilação em vez de em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="ed1ea-111">CA1805: Não inicializar desnecessariamente</span><span class="sxs-lookup"><span data-stu-id="ed1ea-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="ed1ea-112">O tempo de execução do .NET inicializa todos os campos de tipos de referência para seus valores padrão antes de executar o construtor.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="ed1ea-113">Na maioria dos casos, a inicialização explícita de um campo para seu valor padrão é redundante, o que aumenta os custos de manutenção e pode prejudicar o desempenho (como com o maior tamanho do assembly).</span><span class="sxs-lookup"><span data-stu-id="ed1ea-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="ed1ea-114">CA1806: Não ignorar resultados do método</span><span class="sxs-lookup"><span data-stu-id="ed1ea-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="ed1ea-115">Um novo objeto é criado, mas nunca usado, ou um método que cria e retorna uma nova cadeia de caracteres é chamado e a nova cadeia de caracteres nunca é usada ou um método Component Object Model (COM) ou P/Invoke Retorna um HRESULT ou um código de erro que nunca é usado.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="ed1ea-116">CA1810: Inicializar campos estáticos de tipo de referência em linha</span><span class="sxs-lookup"><span data-stu-id="ed1ea-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="ed1ea-117">Quando um tipo declara um construtor estático explícito, o compilador JIT (just-in-time) adiciona uma verificação a cada método estático e construtor de instância do tipo para garantir que o construtor estático tenha sido chamado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="ed1ea-118">As verificações de construtor estático podem diminuir o desempenho.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="ed1ea-119">CA1812: Evitar classes internas sem instâncias</span><span class="sxs-lookup"><span data-stu-id="ed1ea-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="ed1ea-120">Uma instância de um tipo no nível de assembly não é criada pelo código no assembly.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="ed1ea-121">CA1813: Evitar atributos não selados</span><span class="sxs-lookup"><span data-stu-id="ed1ea-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="ed1ea-122">O .NET fornece métodos para recuperar atributos personalizados.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="ed1ea-123">Por padrão, esses métodos pesquisam a hierarquia de herança do atributo.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="ed1ea-124">A validação do atributo elimina a pesquisa na hierarquia de herança e pode melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="ed1ea-125">CA1814: Preferir matrizes denteadas a matrizes multidimensionais</span><span class="sxs-lookup"><span data-stu-id="ed1ea-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="ed1ea-126">Uma matriz denteada é uma matriz cujos elementos são matrizes.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="ed1ea-127">As matrizes que compõem os elementos podem ser de tamanhos diferentes, o que pode resultar em menos espaço desperdiçado para alguns conjuntos de dados.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="ed1ea-128">CA1815: Substituir equals e o operador equals em tipos de valor</span><span class="sxs-lookup"><span data-stu-id="ed1ea-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="ed1ea-129">Para tipos de valor, a implementação herdada de Equals usa a biblioteca Reflection e compara o conteúdo de todos os campos.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="ed1ea-130">Reflection é computacionalmente cara, e pode ser desnecessário comparar a igualdade de cada campo.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="ed1ea-131">Se você espera que os usuários comparem ou classifiquem instâncias, ou usem instâncias como chaves de tabela de hash, o tipo de valor deverá implementar Equals.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="ed1ea-132">CA1819: Propriedades não devem retornar matrizes</span><span class="sxs-lookup"><span data-stu-id="ed1ea-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="ed1ea-133">As matrizes retornadas por propriedades não são protegidas por gravação, mesmo que a propriedade seja somente leitura.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="ed1ea-134">Para manter a matriz à prova de adulteração, a propriedade deve retornar uma cópia da matriz.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="ed1ea-135">Normalmente, os usuários não compreenderão as implicações adversas no desempenho de chamar uma propriedade assim.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="ed1ea-136">CA1820: Testar para verificar se há cadeias de caracteres vazias usando o tamanho da cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="ed1ea-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="ed1ea-137">A comparação de cadeias de caracteres usando-se a propriedade String.Length ou o método String.IsNullOrEmpty é significativamente mais rápida do que o uso de Equals.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="ed1ea-138">CA1821: Remover finalizadores vazios</span><span class="sxs-lookup"><span data-stu-id="ed1ea-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="ed1ea-139">Sempre que possível, evite finalizadores por conta da sobrecarga adicional no desempenho envolvida no acompanhamento do tempo de vida do objeto.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="ed1ea-140">Um finalizador vazio incorre em sobrecarga adicional sem nenhum benefício.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="ed1ea-141">CA1822: Marcar membros como estáticos</span><span class="sxs-lookup"><span data-stu-id="ed1ea-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="ed1ea-142">Membros que não acessam dados de instância ou métodos de instância de chamada podem ser marcados como estáticos (compartilhados em Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ed1ea-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="ed1ea-143">Depois que você marcar os métodos como estáticos, o compilador emitirá sites de chamada não virtuais para esses membros.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="ed1ea-144">Isso pode proporcionar um ganho de desempenho mensurável para o código sensível ao desempenho.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="ed1ea-145">CA1823: Evitar campos particulares não utilizados</span><span class="sxs-lookup"><span data-stu-id="ed1ea-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="ed1ea-146">Foram detectados campos particulares que aparentemente não são acessados no assembly.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="ed1ea-147">CA1824: Marque assemblies com NeutralResourcesLanguageAttribute</span><span class="sxs-lookup"><span data-stu-id="ed1ea-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="ed1ea-148">O atributo NeutralResourcesLanguage informa o Gerenciador de recursos da linguagem que foi usada para exibir os recursos de uma cultura neutra para um assembly.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="ed1ea-149">Isso melhora o desempenho da pesquisa para o primeiro recurso carregado e pode reduzir o conjunto de trabalho.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="ed1ea-150">CA1825: Evitar alocações de matriz de comprimento zero</span><span class="sxs-lookup"><span data-stu-id="ed1ea-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="ed1ea-151">A inicialização de uma matriz de comprimento zero leva à alocação de memória desnecessária.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="ed1ea-152">Em vez disso, use a instância de matriz vazia estaticamente alocada chamando <xref:System.Array.Empty%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ed1ea-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ed1ea-153">A alocação de memória é compartilhada entre todas as invocações desse método.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="ed1ea-154">CA1826: Usar a propriedade em vez do método Linq Enumerable</span><span class="sxs-lookup"><span data-stu-id="ed1ea-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="ed1ea-155"><xref:System.Linq.Enumerable> O método LINQ foi usado em um tipo que dá suporte a uma propriedade equivalente e mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="ed1ea-156">CA1827: Não usar Count/LongCount quando Any puder ser usado</span><span class="sxs-lookup"><span data-stu-id="ed1ea-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="ed1ea-157"><xref:System.Linq.Enumerable.Count%2A> o <xref:System.Linq.Enumerable.LongCount%2A> método or foi usado onde o <xref:System.Linq.Enumerable.Any%2A> método seria mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="ed1ea-158">CA1828: Não usar CountAsync/LongCountAsync quando AnyAsync puder ser usado</span><span class="sxs-lookup"><span data-stu-id="ed1ea-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="ed1ea-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> o <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> método or foi usado onde o <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> método seria mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="ed1ea-160">CA1829: Usar a propriedade Length/Count em vez do método Enumerable.Count</span><span class="sxs-lookup"><span data-stu-id="ed1ea-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="ed1ea-161"><xref:System.Linq.Enumerable.Count%2A> O método LINQ foi usado em um tipo que dá suporte a uma propriedade equivalente, mais eficiente `Length` ou `Count` .</span><span class="sxs-lookup"><span data-stu-id="ed1ea-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="ed1ea-162">CA1830: Preferir os métodos Acrescentar e Inserir fortemente tipados provoca uma sobrecarga no StringBuilder</span><span class="sxs-lookup"><span data-stu-id="ed1ea-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="ed1ea-163"><xref:System.Text.StringBuilder.Append%2A> e <xref:System.Text.StringBuilder.Insert%2A> fornecem sobrecargas para vários tipos além de System. String.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="ed1ea-164">Quando possível, prefira as sobrecargas fortemente tipadas usando ToString () e a sobrecarga baseada em cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="ed1ea-165">CA1831: Usar AsSpan em vez de indexadores baseados em intervalo na cadeia de caracteres quando apropriado</span><span class="sxs-lookup"><span data-stu-id="ed1ea-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="ed1ea-166">Ao usar um indexador de intervalo em uma cadeia de caracteres e atribuir implicitamente o valor a um &lt; tipo de caractere ReadOnlySpan &gt; , o método <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> será usado em vez de <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , que produz uma cópia da parte solicitada da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="ed1ea-167">CA1832: Usar AsSpan ou AsMemory em vez de indexadores baseados em intervalo para obter a parte ReadOnlySpan ou ReadOnlyMemory de uma matriz</span><span class="sxs-lookup"><span data-stu-id="ed1ea-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="ed1ea-168">Ao usar um indexador de intervalo em uma matriz e atribuir implicitamente o valor a um <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601> tipo ou, o método <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> será usado em vez de, o <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> que produzirá uma cópia da parte solicitada da matriz.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="ed1ea-169">CA1833: Usar AsSpan ou AsMemory em vez de indexadores baseados em intervalo para obter a parte Span ou Memory de uma matriz</span><span class="sxs-lookup"><span data-stu-id="ed1ea-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="ed1ea-170">Ao usar um indexador de intervalo em uma matriz e atribuir implicitamente o valor a um <xref:System.Span%601> <xref:System.Memory%601> tipo ou, o método <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> será usado em vez de, o <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> que produzirá uma cópia da parte solicitada da matriz.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="ed1ea-171">CA1834: usar StringBuilder.Append (char) para cadeias de caracteres únicas</span><span class="sxs-lookup"><span data-stu-id="ed1ea-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="ed1ea-172"><xref:System.Text.StringBuilder> tem uma `Append` sobrecarga que usa `char` como argumento.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="ed1ea-173">Prefira chamar a `char` sobrecarga para melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="ed1ea-174">CA1835: prefira as sobrecargas baseadas em Memory' para ' ReadAsync ' e ' WriteAsync '</span><span class="sxs-lookup"><span data-stu-id="ed1ea-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="ed1ea-175">' Stream ' tem uma sobrecarga ' ReadAsync ' que usa um ' byte de memória &lt; &gt; ' como o primeiro argumento e uma sobrecarga ' WriteAsync ' que usa um ' ReadOnlyMemory &lt; byte &gt; ' como o primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="ed1ea-176">Prefira chamar as sobrecargas com base na memória, que são mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="ed1ea-177">CA1836: preferir `IsEmpty` `Count` quando disponível</span><span class="sxs-lookup"><span data-stu-id="ed1ea-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="ed1ea-178">Prefira `IsEmpty` a propriedade que seja mais eficiente do que `Count` , `Length` <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> ou <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para determinar se o objeto contém ou não itens.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="ed1ea-179">CA1837: usar `Environment.ProcessId` em vez de `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="ed1ea-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="ed1ea-180">`Environment.ProcessId` é mais simples e mais rápido do que `Process.GetCurrentProcess().Id` .</span><span class="sxs-lookup"><span data-stu-id="ed1ea-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="ed1ea-181">CA1838: Evite `StringBuilder` parâmetros para P/Invokes</span><span class="sxs-lookup"><span data-stu-id="ed1ea-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="ed1ea-182">O marshaling de `StringBuilder` sempre cria uma cópia de buffer nativo, resultando em várias alocações para uma operação de marshaling.</span><span class="sxs-lookup"><span data-stu-id="ed1ea-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
