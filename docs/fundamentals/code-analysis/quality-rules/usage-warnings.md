---
title: Regras de uso (análise de código)
description: Saiba mais sobre as regras de uso da análise de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8b14d2f92502d5a82e41a322e599745bdcf8b85
ms.sourcegitcommit: a6bd4cad438fe479cbd112eae10f2cd449f06e40
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/08/2020
ms.locfileid: "96585439"
---
# <a name="usage-rules"></a><span data-ttu-id="e6454-103">Regras de uso</span><span class="sxs-lookup"><span data-stu-id="e6454-103">Usage rules</span></span>

<span data-ttu-id="e6454-104">As regras de uso dão suporte ao uso adequado do .NET.</span><span class="sxs-lookup"><span data-stu-id="e6454-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="e6454-105">Nesta seção</span><span class="sxs-lookup"><span data-stu-id="e6454-105">In this section</span></span>

|<span data-ttu-id="e6454-106">Regra</span><span class="sxs-lookup"><span data-stu-id="e6454-106">Rule</span></span>|<span data-ttu-id="e6454-107">Descrição</span><span class="sxs-lookup"><span data-stu-id="e6454-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="e6454-108">CA1801: Examinar parâmetros não utilizados</span><span class="sxs-lookup"><span data-stu-id="e6454-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="e6454-109">Uma assinatura de método inclui um parâmetro que não é usado no corpo do método.</span><span class="sxs-lookup"><span data-stu-id="e6454-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="e6454-110">CA1816: Chamar GC.SuppressFinalize corretamente</span><span class="sxs-lookup"><span data-stu-id="e6454-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="e6454-111">Um método que é uma implementação de Dispose não chama `GC.SuppressFinalize` ; ou um método que não é uma implementação de `Dispose` chamadas `GC.SuppressFinalize` ; ou um método chama `GC.SuppressFinalize` e passa algo diferente de `this` ( `Me` em Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e6454-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="e6454-112">CA2200: Relançar para preservar detalhes da pilha</span><span class="sxs-lookup"><span data-stu-id="e6454-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="e6454-113">Uma exceção é lançada novamente e a exceção é especificada explicitamente na instrução throw.</span><span class="sxs-lookup"><span data-stu-id="e6454-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="e6454-114">Se uma exceção for lançada novamente pela especificação da exceção na instrução throw, a lista de chamadas de método entre o método original que lançou a exceção e o método atual será perdida.</span><span class="sxs-lookup"><span data-stu-id="e6454-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="e6454-115">CA2201: Não acionar tipos de exceção reservados</span><span class="sxs-lookup"><span data-stu-id="e6454-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="e6454-116">Isso torna o erro original difícil de detectar e depurar.</span><span class="sxs-lookup"><span data-stu-id="e6454-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="e6454-117">CA2207: Inicializar campos estáticos de tipo de valor em linha</span><span class="sxs-lookup"><span data-stu-id="e6454-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="e6454-118">Um tipo de valor declara um construtor estático explícito.</span><span class="sxs-lookup"><span data-stu-id="e6454-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="e6454-119">Para corrigir uma violação dessa regra, inicialize todos os dados estáticos quando declarados e remova o construtor estático.</span><span class="sxs-lookup"><span data-stu-id="e6454-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="e6454-120">CA2208: Criar instância de exceções de argumento corretamente</span><span class="sxs-lookup"><span data-stu-id="e6454-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="e6454-121">For feita uma chamada para o construtor padrão (sem parâmetros) de um tipo de exceção que seja ou derive de ArgumentException, ou um argumento de cadeia de caracteres incorreto é passado para um construtor com parâmetros de um tipo de exceção que seja ou derive de ArgumentException.</span><span class="sxs-lookup"><span data-stu-id="e6454-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="e6454-122">CA2211: Campos não constantes não devem ser visíveis</span><span class="sxs-lookup"><span data-stu-id="e6454-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="e6454-123">Campos estáticos que não são constantes ou somente leitura não são thread-safe.</span><span class="sxs-lookup"><span data-stu-id="e6454-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="e6454-124">O acesso a esse campo deve ser cuidadosamente controlado e requer técnicas de programação avançadas para sincronizar o acesso ao objeto de classe.</span><span class="sxs-lookup"><span data-stu-id="e6454-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="e6454-125">CA2213: Campos descartáveis devem ser descartados</span><span class="sxs-lookup"><span data-stu-id="e6454-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="e6454-126">Um tipo que implementa <xref:System.IDisposable?displayProperty=fullName> declara campos que são de tipos que também implementam `IDisposable` .</span><span class="sxs-lookup"><span data-stu-id="e6454-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="e6454-127">O `Dispose` método do campo não é chamado pelo `Dispose` método do tipo declarativo.</span><span class="sxs-lookup"><span data-stu-id="e6454-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="e6454-128">CA2214: Não chamar métodos substituíveis em construtores</span><span class="sxs-lookup"><span data-stu-id="e6454-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="e6454-129">Quando um construtor chama um método virtual, é possível que o construtor da instância que invoca o método não tenha sido executado.</span><span class="sxs-lookup"><span data-stu-id="e6454-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="e6454-130">CA2215: Métodos Dispose devem chamar o descarte da classe base</span><span class="sxs-lookup"><span data-stu-id="e6454-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="e6454-131">Se um tipo for herdado de um tipo descartável, ele deverá chamar o `Dispose` método do tipo base de seu próprio `Dispose` método.</span><span class="sxs-lookup"><span data-stu-id="e6454-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="e6454-132">CA2216: Tipos descartáveis devem declarar o finalizador</span><span class="sxs-lookup"><span data-stu-id="e6454-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="e6454-133">Um tipo que implementa <xref:System.IDisposable?displayProperty=fullName> e tem campos que sugerem o uso de recursos não gerenciados, não implementa um finalizador conforme descrito pelo `Object.Finalize` .</span><span class="sxs-lookup"><span data-stu-id="e6454-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="e6454-134">CA2217: Não marcar enumerações com FlagsAttribute</span><span class="sxs-lookup"><span data-stu-id="e6454-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="e6454-135">Uma enumeração visível externamente é marcada com `FlagsAttribute` , e tem um ou mais valores que não são potências de duas ou uma combinação de outros valores definidos na enumeração.</span><span class="sxs-lookup"><span data-stu-id="e6454-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="e6454-136">CA2218: Substituir GetHashCode ao substituir Equals</span><span class="sxs-lookup"><span data-stu-id="e6454-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="e6454-137">Um tipo público substitui <xref:System.Object.Equals%2A?displayProperty=fullName> , mas não substitui <xref:System.Object.GetHashCode%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="e6454-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="e6454-138">CA2219: Não acionar exceções em cláusulas de exceção</span><span class="sxs-lookup"><span data-stu-id="e6454-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="e6454-139">Quando uma exceção é acionada em uma cláusula finally ou fault, a nova exceção oculta a exceção ativa.</span><span class="sxs-lookup"><span data-stu-id="e6454-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="e6454-140">Quando uma exceção é acionada em uma cláusula de filtro, o tempo de execução captura silenciosamente a exceção.</span><span class="sxs-lookup"><span data-stu-id="e6454-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="e6454-141">Isso torna o erro original difícil de detectar e depurar.</span><span class="sxs-lookup"><span data-stu-id="e6454-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="e6454-142">CA2224: Substituir equals ao sobrecarregar operador equals</span><span class="sxs-lookup"><span data-stu-id="e6454-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="e6454-143">Um tipo público implementa o operador de igualdade, mas não substitui <xref:System.Object.Equals%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="e6454-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="e6454-144">CA2225: Sobrecargas de operador têm alternativas nomeadas</span><span class="sxs-lookup"><span data-stu-id="e6454-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="e6454-145">Uma sobrecarga de operador foi detectada, e o método alternativo nomeado esperado não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="e6454-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="e6454-146">O membro alternativo nomeado fornece acesso à mesma funcionalidade que o operador e é fornecido para desenvolvedores que programam em idiomas que não dão suporte a operadores sobrecarregados.</span><span class="sxs-lookup"><span data-stu-id="e6454-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="e6454-147">CA2226: Operadores devem ter sobrecargas simétricas</span><span class="sxs-lookup"><span data-stu-id="e6454-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="e6454-148">Um tipo implementa o operador de igualdade ou desigualdade e não implementa o operador oposto.</span><span class="sxs-lookup"><span data-stu-id="e6454-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="e6454-149">CA2227: Propriedades de coleção devem ser somente leitura</span><span class="sxs-lookup"><span data-stu-id="e6454-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="e6454-150">Uma propriedade collection gravável permite que um usuário substitua a coleção por uma coleção diferente.</span><span class="sxs-lookup"><span data-stu-id="e6454-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="e6454-151">Uma propriedade somente leitura evita que a coleção seja substituída, mas ainda permite que membros individuais sejam definidos.</span><span class="sxs-lookup"><span data-stu-id="e6454-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="e6454-152">CA2229: Implementar construtores de serialização</span><span class="sxs-lookup"><span data-stu-id="e6454-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="e6454-153">Para corrigir uma violação dessa regra, implemente o construtor de serialização.</span><span class="sxs-lookup"><span data-stu-id="e6454-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="e6454-154">Para uma classe lacrada, torne o construtor particular; do contrário, deixe-o protegido.</span><span class="sxs-lookup"><span data-stu-id="e6454-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="e6454-155">CA2231: Sobrecarregar operador equals ao substituir ValueType.Equals</span><span class="sxs-lookup"><span data-stu-id="e6454-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="e6454-156">Um tipo de valor substitui `Object.Equals` mas não implementa o operador de igualdade.</span><span class="sxs-lookup"><span data-stu-id="e6454-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="e6454-157">CA2234: Passar objetos System.Uri em vez de cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="e6454-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="e6454-158">Foi feita uma chamada para um método com um parâmetro de cadeia de caracteres cujo nome contém "uri", "URI", "urn", "URN", "url" ou "URL".</span><span class="sxs-lookup"><span data-stu-id="e6454-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="e6454-159">O tipo declarativo do método contém uma sobrecarga de método correspondente que tem um <xref:System.Uri?displayProperty=fullName> parâmetro.</span><span class="sxs-lookup"><span data-stu-id="e6454-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="e6454-160">CA2235: Marcar todos os campos não serializáveis</span><span class="sxs-lookup"><span data-stu-id="e6454-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="e6454-161">Um campo de instância de um tipo que não seja serializável é declarado em um tipo que é serializável.</span><span class="sxs-lookup"><span data-stu-id="e6454-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="e6454-162">CA2237: Marcar tipos ISerializable com SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="e6454-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="e6454-163">Para ser reconhecido pelo Common Language Runtime como serializável, os tipos devem ser marcados com o atributo SerializableAttribute, mesmo que o tipo use uma rotina de serialização personalizada por meio da implementação da `ISerializable` interface.</span><span class="sxs-lookup"><span data-stu-id="e6454-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="e6454-164">CA2241: Fornecer argumentos corretos para métodos de formatação</span><span class="sxs-lookup"><span data-stu-id="e6454-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="e6454-165">O argumento de formato passado para não <xref:System.String.Format%2A?displayProperty=nameWithType> contém um item de formato que corresponde a cada argumento de objeto ou vice-versa.</span><span class="sxs-lookup"><span data-stu-id="e6454-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="e6454-166">CA2242: Testar para NaN corretamente</span><span class="sxs-lookup"><span data-stu-id="e6454-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="e6454-167">Essa expressão testa um valor em relação a `Single.Nan` ou `Double.Nan` .</span><span class="sxs-lookup"><span data-stu-id="e6454-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="e6454-168">Use `Single.IsNan(Single)` ou `Double.IsNan(Double)` para testar o valor.</span><span class="sxs-lookup"><span data-stu-id="e6454-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="e6454-169">CA2243: Literais de cadeias de caracteres de atributo devem ser analisados corretamente</span><span class="sxs-lookup"><span data-stu-id="e6454-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="e6454-170">O parâmetro literal da cadeia de caracteres de um atributo não é analisado corretamente para uma URL, um GUID ou uma versão.</span><span class="sxs-lookup"><span data-stu-id="e6454-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="e6454-171">CA2244: Não duplicar inicializações de elementos indexados</span><span class="sxs-lookup"><span data-stu-id="e6454-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="e6454-172">Um inicializador de objeto tem mais de um inicializador de elemento indexado com o mesmo índice de constante.</span><span class="sxs-lookup"><span data-stu-id="e6454-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="e6454-173">Todos, exceto o último inicializador, são redundantes.</span><span class="sxs-lookup"><span data-stu-id="e6454-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="e6454-174">CA2245: Não atribuir uma propriedade a si mesma</span><span class="sxs-lookup"><span data-stu-id="e6454-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="e6454-175">Uma propriedade foi acidentalmente atribuída a ela mesma.</span><span class="sxs-lookup"><span data-stu-id="e6454-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="e6454-176">CA2246: Não designar um símbolo e o membro dele na mesma instrução</span><span class="sxs-lookup"><span data-stu-id="e6454-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="e6454-177">Não é recomendável atribuir um símbolo e seu membro, ou seja, um campo ou uma propriedade, na mesma instrução.</span><span class="sxs-lookup"><span data-stu-id="e6454-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="e6454-178">Não fica claro se o acesso de membro foi projetado para usar o valor antigo do símbolo antes da atribuição ou o novo valor da atribuição nesta instrução.</span><span class="sxs-lookup"><span data-stu-id="e6454-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="e6454-179">CA2247: O argumento passado para o construtor TaskCompletionSource deve ser a enumeração TaskCreationOptions em vez da enumeração TaskContinuationOptions</span><span class="sxs-lookup"><span data-stu-id="e6454-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2246.md)|<span data-ttu-id="e6454-180">TaskCompletionSource tem construtores que usam TaskCreationOptions que controlam a tarefa subjacente e construtores que assumem o estado do objeto armazenado na tarefa.</span><span class="sxs-lookup"><span data-stu-id="e6454-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="e6454-181">Passar acidentalmente um TaskContinuationOptions em vez de um TaskCreationOptions resultará na chamada que trata as opções como estado.</span><span class="sxs-lookup"><span data-stu-id="e6454-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="e6454-182">CA2248: forneça o argumento ' Enum ' correto para ' Enum. HasFlag '</span><span class="sxs-lookup"><span data-stu-id="e6454-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="e6454-183">O tipo de enumeração passado como um argumento para a `HasFlag` chamada do método é diferente do tipo de enumeração de chamada.</span><span class="sxs-lookup"><span data-stu-id="e6454-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="e6454-184">CA2249: Considerar o uso de String.Contains em vez de String.IndexOf</span><span class="sxs-lookup"><span data-stu-id="e6454-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="e6454-185">Chamadas para `string.IndexOf` onde o resultado é usado para verificar a presença ou a ausência de uma subcadeia de caracteres podem ser substituídas por `string.Contains` .</span><span class="sxs-lookup"><span data-stu-id="e6454-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
