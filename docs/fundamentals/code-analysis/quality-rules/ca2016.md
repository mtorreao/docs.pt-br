---
title: 'CA2016: encaminhe o parâmetro CancellationToken para métodos que usam um (análise de código)'
description: 'Saiba mais sobre a regra de análise de código CA2016: encaminhar o parâmetro CancellationToken para métodos que usam um'
ms.date: 06/18/2020
ms.topic: reference
f1_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
helpviewer_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: d8d76ca576a4e175528f066741914739a570af41
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/25/2020
ms.locfileid: "96584682"
---
# <a name="ca2016-forward-the-cancellationtoken-parameter-to-methods-that-take-one"></a><span data-ttu-id="4218a-103">CA2016: Encaminhe o parâmetro CancellationToken para os métodos que recebem um</span><span class="sxs-lookup"><span data-stu-id="4218a-103">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>

| | <span data-ttu-id="4218a-104">Valor</span><span class="sxs-lookup"><span data-stu-id="4218a-104">Value</span></span> |
|-|-|
|<span data-ttu-id="4218a-105">TypeName</span><span class="sxs-lookup"><span data-stu-id="4218a-105">TypeName</span></span>|<span data-ttu-id="4218a-106">ForwardCancellationTokenToInvocations</span><span class="sxs-lookup"><span data-stu-id="4218a-106">ForwardCancellationTokenToInvocations</span></span>|
| <span data-ttu-id="4218a-107">**ID da regra**</span><span class="sxs-lookup"><span data-stu-id="4218a-107">**Rule ID**</span></span> |<span data-ttu-id="4218a-108">CA2016</span><span class="sxs-lookup"><span data-stu-id="4218a-108">CA2016</span></span>|
| <span data-ttu-id="4218a-109">**Categoria**</span><span class="sxs-lookup"><span data-stu-id="4218a-109">**Category**</span></span> |<span data-ttu-id="4218a-110">Microsoft. performance</span><span class="sxs-lookup"><span data-stu-id="4218a-110">Microsoft.Performance</span></span>|
| <span data-ttu-id="4218a-111">**A correção está sendo interrompida ou não está sendo interrompida**</span><span class="sxs-lookup"><span data-stu-id="4218a-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="4218a-112">Sem interrupção</span><span class="sxs-lookup"><span data-stu-id="4218a-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="4218a-113">Causa</span><span class="sxs-lookup"><span data-stu-id="4218a-113">Cause</span></span>

<span data-ttu-id="4218a-114">Essa regra localiza invocações de método que poderiam aceitar um <xref:System.Threading.CancellationToken> parâmetro, mas que não estão passando por nenhum e sugere que encaminhe o método pai `CancellationToken` para eles.</span><span class="sxs-lookup"><span data-stu-id="4218a-114">This rule locates method invocations that could accept a <xref:System.Threading.CancellationToken> parameter, but are not passing any, and suggests to forward the parent method's `CancellationToken` to them.</span></span>

## <a name="rule-description"></a><span data-ttu-id="4218a-115">Descrição da regra</span><span class="sxs-lookup"><span data-stu-id="4218a-115">Rule description</span></span>

<span data-ttu-id="4218a-116">Essa regra analisa as definições de método que usam `CancellationToken` como seu último parâmetro e, em seguida, analisa todos os métodos invocados em seu corpo.</span><span class="sxs-lookup"><span data-stu-id="4218a-116">This rule analyzes method definitions that take a `CancellationToken` as their last parameter, then analyzes all methods invoked in its body.</span></span> <span data-ttu-id="4218a-117">Se qualquer uma das invocações de método puder aceitar um `CancellationToken` como o último parâmetro ou se tiver uma sobrecarga que usa um `CancellationToken` como o último parâmetro, a regra sugere usar essa opção em vez de garantir que a notificação de cancelamento seja propagada para todas as operações que possam ouvi-lo.</span><span class="sxs-lookup"><span data-stu-id="4218a-117">If any of the method invocations can either accept a `CancellationToken` as the last parameter, or have an overload that takes a `CancellationToken` as the last parameter, then the rule suggests using that option instead to ensure that the cancellation notification gets propagated to all operations that can listen to it.</span></span>

> [!NOTE]
> <span data-ttu-id="4218a-118">A regra CA2016 está disponível em todas as versões do .NET em que o `CancellationToken` tipo está disponível.</span><span class="sxs-lookup"><span data-stu-id="4218a-118">Rule CA2016 is available in all .NET versions where the `CancellationToken` type is available.</span></span> <span data-ttu-id="4218a-119">Consulte [a seção "aplica-se a" do CancellationToken](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span><span class="sxs-lookup"><span data-stu-id="4218a-119">See [CancellationToken "Applies to" section](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="4218a-120">Como corrigir violações</span><span class="sxs-lookup"><span data-stu-id="4218a-120">How to fix violations</span></span>

<span data-ttu-id="4218a-121">Você pode corrigi-los manualmente ou pode optar por permitir que o Visual Studio faça isso para você, passando o mouse sobre a lâmpada que aparece ao lado da invocação do método e selecionando a alteração sugerida.</span><span class="sxs-lookup"><span data-stu-id="4218a-121">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span>

<span data-ttu-id="4218a-122">O exemplo a seguir mostra duas alterações sugeridas:</span><span class="sxs-lookup"><span data-stu-id="4218a-122">The following example shows two suggested changes:</span></span>

![Regra CA2016-encaminhar o parâmetro CancellationToken para métodos que usam um](media/ca2016-diagnose.png)

<span data-ttu-id="4218a-124">É seguro suprimir uma violação dessa regra se você não estiver preocupado em encaminhar a notificação de operação cancelada para invocações de método mais baixas.</span><span class="sxs-lookup"><span data-stu-id="4218a-124">It's safe to suppress a violation of this rule if you're not concerned about forwarding the canceled operation notification to lower method invocations.</span></span> <span data-ttu-id="4218a-125">Você também pode passar explicitamente `default` em C# ( `Nothing` em Visual Basic) ou <xref:System.Threading.CancellationToken.None> para suprimir a violação da regra.</span><span class="sxs-lookup"><span data-stu-id="4218a-125">You can also explicitly pass `default` in C# (`Nothing` in Visual Basic) or <xref:System.Threading.CancellationToken.None> to suppress the rule violation.</span></span>

<span data-ttu-id="4218a-126">A regra pode detectar uma variedade de violações.</span><span class="sxs-lookup"><span data-stu-id="4218a-126">The rule can detect a variety of violations.</span></span> <span data-ttu-id="4218a-127">Os exemplos a seguir mostram casos que a regra pode detectar:</span><span class="sxs-lookup"><span data-stu-id="4218a-127">The following examples show cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="4218a-128">Exemplo 1</span><span class="sxs-lookup"><span data-stu-id="4218a-128">Example 1</span></span>

<span data-ttu-id="4218a-129">A regra irá sugerir o encaminhamento do `c` parâmetro de `MyMethod` para a `MyMethodWithDefault` invocação, porque o método define um parâmetro de token opcional:</span><span class="sxs-lookup"><span data-stu-id="4218a-129">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method defines an optional token parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="4218a-130">Correção:</span><span class="sxs-lookup"><span data-stu-id="4218a-130">Fix:</span></span>

<span data-ttu-id="4218a-131">Encaminhe o `c` parâmetro:</span><span class="sxs-lookup"><span data-stu-id="4218a-131">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(c);
        }
```

<span data-ttu-id="4218a-132">Se você não estiver preocupado com o encaminhamento de notificações de cancelamento para as invocações inferiores, você pode:</span><span class="sxs-lookup"><span data-stu-id="4218a-132">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="4218a-133">Passe explicitamente `default` :</span><span class="sxs-lookup"><span data-stu-id="4218a-133">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(default);
        }
```

<span data-ttu-id="4218a-134">Ou passe explicitamente `CancellationToken.None` :</span><span class="sxs-lookup"><span data-stu-id="4218a-134">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(CancellationToken.None);
        }
```

### <a name="example-2"></a><span data-ttu-id="4218a-135">Exemplo 2</span><span class="sxs-lookup"><span data-stu-id="4218a-135">Example 2</span></span>

<span data-ttu-id="4218a-136">A regra irá sugerir o encaminhamento do `c` parâmetro de `MyMethod` para a `MyMethodWithDefault` invocação, porque o método tem uma sobrecarga que usa um `CancellationToken` parâmetro:</span><span class="sxs-lookup"><span data-stu-id="4218a-136">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method has an overload that takes a `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethodWithOverload(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="4218a-137">Correção:</span><span class="sxs-lookup"><span data-stu-id="4218a-137">Fix:</span></span>

<span data-ttu-id="4218a-138">Encaminhe o `c` parâmetro:</span><span class="sxs-lookup"><span data-stu-id="4218a-138">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(c);
        }
```

<span data-ttu-id="4218a-139">Se você não estiver preocupado com o encaminhamento de notificações de cancelamento para as invocações inferiores, você pode:</span><span class="sxs-lookup"><span data-stu-id="4218a-139">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="4218a-140">Passe explicitamente `default` :</span><span class="sxs-lookup"><span data-stu-id="4218a-140">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(default);
        }
```

<span data-ttu-id="4218a-141">Ou passe explicitamente `CancellationToken.None` :</span><span class="sxs-lookup"><span data-stu-id="4218a-141">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(CancellationToken.None);
        }
```

## <a name="non-violation-examples"></a><span data-ttu-id="4218a-142">Exemplos de não violação</span><span class="sxs-lookup"><span data-stu-id="4218a-142">Non-violation examples</span></span>

<span data-ttu-id="4218a-143">O `CancellationToken` parâmetro no método pai não está na última posição:</span><span class="sxs-lookup"><span data-stu-id="4218a-143">The `CancellationToken` parameter in the parent method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c, int lastParameter)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="4218a-144">O `CancellationToken` parâmetro no método padrão não está na última posição:</span><span class="sxs-lookup"><span data-stu-id="4218a-144">The `CancellationToken` parameter in the default method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default, int lastParameter = 0)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="4218a-145">O `CancellationToken` parâmetro no método Overload não está na última posição:</span><span class="sxs-lookup"><span data-stu-id="4218a-145">The `CancellationToken` parameter in the overload method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(int lastParameter)
        {
        }
        public static void MyMethodWithOverload(CancellationToken ct, int lastParameter)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="4218a-146">O método pai define mais de um `CancellationToken` parâmetro:</span><span class="sxs-lookup"><span data-stu-id="4218a-146">The parent method defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c1, CancellationToken c2)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="4218a-147">O método com padrões define mais de um `CancellationToken` parâmetro:</span><span class="sxs-lookup"><span data-stu-id="4218a-147">The method with defaults defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken c1 = default, CancellationToken c2 = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="4218a-148">A sobrecarga do método define mais de um `CancellationToken` parâmetro:</span><span class="sxs-lookup"><span data-stu-id="4218a-148">The method overload defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(CancellationToken c1, CancellationToken c2)
        {
        }

        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```
