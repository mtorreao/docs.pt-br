---
title: 'CA1835: prefira as sobrecargas baseadas em memória dos métodos ReadAsync/WriteAsync em classes baseadas em fluxo (análise de código)'
description: 'Saiba mais sobre a regra de análise de código CA1835: prefira as sobrecargas baseadas em memória dos métodos ReadAsync/WriteAsync em classes baseadas em fluxo'
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: a3730f911f55af27f75ca41a8a9427a29efd0a18
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/25/2020
ms.locfileid: "96584834"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a><span data-ttu-id="1c7cf-103">CA1835: prefira as sobrecargas baseadas em memória dos métodos ReadAsync/WriteAsync em classes baseadas em fluxo</span><span class="sxs-lookup"><span data-stu-id="1c7cf-103">CA1835: Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes</span></span>

| | <span data-ttu-id="1c7cf-104">Valor</span><span class="sxs-lookup"><span data-stu-id="1c7cf-104">Value</span></span> |
|-|-|
|<span data-ttu-id="1c7cf-105">TypeName</span><span class="sxs-lookup"><span data-stu-id="1c7cf-105">TypeName</span></span>|<span data-ttu-id="1c7cf-106">PreferStreamAsyncMemoryOverlodas</span><span class="sxs-lookup"><span data-stu-id="1c7cf-106">PreferStreamAsyncMemoryOverlodas</span></span>|
| <span data-ttu-id="1c7cf-107">**ID da regra**</span><span class="sxs-lookup"><span data-stu-id="1c7cf-107">**Rule ID**</span></span> |<span data-ttu-id="1c7cf-108">CA1835</span><span class="sxs-lookup"><span data-stu-id="1c7cf-108">CA1835</span></span>|
| <span data-ttu-id="1c7cf-109">**Categoria**</span><span class="sxs-lookup"><span data-stu-id="1c7cf-109">**Category**</span></span> |<span data-ttu-id="1c7cf-110">Microsoft. performance</span><span class="sxs-lookup"><span data-stu-id="1c7cf-110">Microsoft.Performance</span></span>|
| <span data-ttu-id="1c7cf-111">**A correção está sendo interrompida ou não está sendo interrompida**</span><span class="sxs-lookup"><span data-stu-id="1c7cf-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="1c7cf-112">Sem interrupção</span><span class="sxs-lookup"><span data-stu-id="1c7cf-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="1c7cf-113">Causa</span><span class="sxs-lookup"><span data-stu-id="1c7cf-113">Cause</span></span>

<span data-ttu-id="1c7cf-114">Essa regra localiza invocações esperadas das sobrecargas de método com base em Byte-array para `ReadAsync` e `WriteAsync` , e sugere o uso de sobrecargas de método baseado em memória, pois elas são mais eficientes.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-114">This rule locates awaited invocations of the byte-array-based method overloads for `ReadAsync` and `WriteAsync`, and suggests using the memory-based method overloads instead, because they are more efficient.</span></span>

## <a name="rule-description"></a><span data-ttu-id="1c7cf-115">Descrição da regra</span><span class="sxs-lookup"><span data-stu-id="1c7cf-115">Rule description</span></span>

<span data-ttu-id="1c7cf-116">As sobrecargas do método baseado em memória têm um uso de memória mais eficiente do que as baseadas em matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-116">The memory-based method overloads have a more efficient memory usage than the byte array-based ones.</span></span>

<span data-ttu-id="1c7cf-117">A regra funciona `ReadAsync` e `WriteAsync` invocações de qualquer classe que herda de <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="1c7cf-117">The rule works on `ReadAsync` and `WriteAsync` invocations of any class that inherits from <xref:System.IO.Stream>.</span></span>

<span data-ttu-id="1c7cf-118">A regra só funciona quando o método é precedido pela `await` palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-118">The rule only works when the method is preceded by the `await` keyword.</span></span>

|<span data-ttu-id="1c7cf-119">Método detectado</span><span class="sxs-lookup"><span data-stu-id="1c7cf-119">Detected method</span></span>|<span data-ttu-id="1c7cf-120">Método sugerido</span><span class="sxs-lookup"><span data-stu-id="1c7cf-120">Suggested method</span></span>|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<span data-ttu-id="1c7cf-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> com `CancellationToken` definido como `default` em C# ou `Nothing` em Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<span data-ttu-id="1c7cf-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> com `CancellationToken` definido como `default` em C# ou `Nothing` em Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="1c7cf-123">Certifique-se de passar `offset` os `count` argumentos de inteiro e para `Memory` as `ReadOnlyMemory` instâncias criadas.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-123">Make sure to pass the `offset` and `count` integer arguments to the created `Memory` or `ReadOnlyMemory` instances.</span></span>

> [!NOTE]
> <span data-ttu-id="1c7cf-124">A regra CA1835 está disponível em todas as versões do .NET em que as sobrecargas baseadas em memória estão disponíveis:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-124">Rule CA1835 is available in all .NET versions where the memory-based overloads are available:</span></span>
>
> - <span data-ttu-id="1c7cf-125">.NET Standard 2,1 e acima.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-125">.NET Standard 2.1 and above.</span></span>
> - <span data-ttu-id="1c7cf-126">.NET Core 2,1 e posterior.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-126">.NET Core 2.1 and above.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="1c7cf-127">Como corrigir violações</span><span class="sxs-lookup"><span data-stu-id="1c7cf-127">How to fix violations</span></span>

<span data-ttu-id="1c7cf-128">Você pode corrigi-los manualmente ou pode optar por permitir que o Visual Studio faça isso para você, passando o mouse sobre a lâmpada que aparece ao lado da invocação do método e selecionando a alteração sugerida.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-128">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span> <span data-ttu-id="1c7cf-129">Exemplo:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-129">Example:</span></span>

![Correção de código para CA1835-prefira as sobrecargas baseadas em memória dos métodos ReadAsync/WriteAsync em classes baseadas em fluxo](media/ca1835-codefix.png)

<span data-ttu-id="1c7cf-131">A regra pode detectar uma variedade de violações para os `ReadAsync` `WriteAsync` métodos e.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-131">The rule can detect a variety of violations for the `ReadAsync` and `WriteAsync` methods.</span></span> <span data-ttu-id="1c7cf-132">Aqui estão exemplos dos casos que a regra pode detectar:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-132">Here are examples of the cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="1c7cf-133">Exemplo 1</span><span class="sxs-lookup"><span data-stu-id="1c7cf-133">Example 1</span></span>

<span data-ttu-id="1c7cf-134">Invocações de `ReadAsync` , sem e com um `CancellationToken` argumento:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-134">Invocations of `ReadAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="1c7cf-135">Correção:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-135">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a><span data-ttu-id="1c7cf-136">Exemplo 2</span><span class="sxs-lookup"><span data-stu-id="1c7cf-136">Example 2</span></span>

<span data-ttu-id="1c7cf-137">Invocações de `WriteAsync` , sem e com um `CancellationToken` argumento:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-137">Invocations of `WriteAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="1c7cf-138">Correção:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-138">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a><span data-ttu-id="1c7cf-139">Exemplo 3</span><span class="sxs-lookup"><span data-stu-id="1c7cf-139">Example 3</span></span>

<span data-ttu-id="1c7cf-140">Invocações com `ConfigureAwait` :</span><span class="sxs-lookup"><span data-stu-id="1c7cf-140">Invocations with `ConfigureAwait`:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

<span data-ttu-id="1c7cf-141">Correção:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-141">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a><span data-ttu-id="1c7cf-142">Não violações</span><span class="sxs-lookup"><span data-stu-id="1c7cf-142">Non-violations</span></span>

<span data-ttu-id="1c7cf-143">A seguir, alguns exemplos de invocações em que a regra **não** será acionada.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-143">Following are some examples of invocations where the rule will **not** be fired.</span></span>

<span data-ttu-id="1c7cf-144">O valor de retorno é salvo em uma `Task` variável em vez de ser aguardado:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-144">The return value is saved in a `Task` variable instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

<span data-ttu-id="1c7cf-145">O valor de retorno é retornado pelo método de disposição em vez de ser aguardado:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-145">The return value is returned by the wrapping method instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

<span data-ttu-id="1c7cf-146">O valor de retorno é usado para chamar `ContinueWith` , que é o método que está sendo aguardado:</span><span class="sxs-lookup"><span data-stu-id="1c7cf-146">The return value is used to call `ContinueWith`, which is the method being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="1c7cf-147">Quando suprimir avisos</span><span class="sxs-lookup"><span data-stu-id="1c7cf-147">When to suppress warnings</span></span>

<span data-ttu-id="1c7cf-148">É seguro suprimir uma violação dessa regra se você não estiver preocupado em melhorar o desempenho ao ler ou gravar buffers em classes baseadas em fluxo.</span><span class="sxs-lookup"><span data-stu-id="1c7cf-148">It's safe to suppress a violation of this rule if you're not concerned about improving performance when reading or writing buffers in stream-based classes.</span></span>

## <a name="see-also"></a><span data-ttu-id="1c7cf-149">Confira também</span><span class="sxs-lookup"><span data-stu-id="1c7cf-149">See also</span></span>

- [<span data-ttu-id="1c7cf-150">Regras de desempenho</span><span class="sxs-lookup"><span data-stu-id="1c7cf-150">Performance rules</span></span>](performance-warnings.md)
