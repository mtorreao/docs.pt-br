---
title: Etapas no fluxo de trabalho de DevOps loop externo para um aplicativo de Docker
description: Aprenda as etapas do "loop externo" do fluxo de trabalho de DevOps
ms.date: 01/06/2021
ms.openlocfilehash: bfac2d2c7866bfd11cd18201a93cb17a72cae588
ms.sourcegitcommit: 7ef96827b161ef3fcde75f79d839885632e26ef1
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/07/2021
ms.locfileid: "97970291"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="c4a7c-103">Etapas no fluxo de trabalho de DevOps loop externo para um aplicativo de Docker</span><span class="sxs-lookup"><span data-stu-id="c4a7c-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="c4a7c-104">A Figura 5-1 traz uma representação de ponta a ponta das etapas que compõem o fluxo de trabalho de loop externo de DevOps.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="c4a7c-105">Ele mostra o "loop externo" de DevOps.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="c4a7c-106">Quando o código é enviado por push ao repositório, um pipeline de CI é iniciado, seguido pelo pipeline de CD, em que o aplicativo é implantado.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="c4a7c-107">As métricas coletadas dos aplicativos implantados são fornecidas para a carga de trabalho de desenvolvimento, na qual ocorre o "loop interno", para que as equipes de desenvolvimento tenham dados reais para responder às necessidades de negócios e dos usuários.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![Diagrama mostrando as 6 etapas do fluxo de trabalho de loop externo DevOps.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="c4a7c-109">**Figura 5-1**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-109">**Figure 5-1**.</span></span> <span data-ttu-id="c4a7c-110">Fluxo de trabalho do loop externo de DevOps para aplicativos do Docker com ferramentas da Microsoft</span><span class="sxs-lookup"><span data-stu-id="c4a7c-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="c4a7c-111">Agora, vamos examinar cada uma dessas etapas com mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="c4a7c-112">Etapa 1: fluxo de trabalho de desenvolvimento de loop interno</span><span class="sxs-lookup"><span data-stu-id="c4a7c-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="c4a7c-113">Esta etapa é explicada em detalhes no Capítulo 4. Entretanto, para recapitular, aqui é onde o loop externo começa, no momento em que um desenvolvedor enviar código por push para o sistema de gerenciamento de controle do código-fonte (como o Git), iniciando ações do pipeline de CI.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="c4a7c-114">Etapa 2: Source-Code a integração e o gerenciamento de controle com o Azure DevOps Services e o Git</span><span class="sxs-lookup"><span data-stu-id="c4a7c-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="c4a7c-115">Nesta etapa, você precisa ter um sistema de controle de versão para reunir uma versão consolidada de todo o código proveniente de diferentes desenvolvedores na equipe.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="c4a7c-116">Ainda que o SCC (controle do código-fonte) e o gerenciamento de código-fonte possam parecer naturais para a maioria dos desenvolvedores, ao criar aplicativos do Docker em um ciclo de vida de DevOps, é essencial enfatizar que você não deve enviar as imagens do Docker com o aplicativo diretamente para o Registro do Docker global (como o Registro de Contêiner do Azure ou o Docker Hub) do computador do desenvolvedor.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="c4a7c-117">Pelo contrário, as imagens do Docker a serem lançadas e implantadas em ambientes de produção devem ser criadas apenas no código-fonte que está sendo integrado em seu build global ou pipeline de CI, com base em seu repositório de código-fonte (como o Git).</span><span class="sxs-lookup"><span data-stu-id="c4a7c-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="c4a7c-118">As imagens locais, geradas por desenvolvedores, devem ser usadas por eles apenas ao testar dentro de seus próprios computadores.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="c4a7c-119">Por isso, é essencial ter o pipeline de DevOps ativado no código de SCC.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="c4a7c-120">O Azure DevOps Services e o Team Foundation Server dão suporte ao Git e ao Controle de Versão do Team Foundation.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="c4a7c-121">Você pode escolher entre eles e usá-los para ter uma experiência de ponta a ponta da Microsoft.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="c4a7c-122">No entanto, você também pode gerenciar seu código em repositórios externos (como GitHub, repositórios git locais ou subversão) e ainda conseguir se conectar a ele e obter o código como ponto de partida para o pipeline de CI DevOps.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="c4a7c-123">Etapa 3: Compilar, CI, integrar e testar com o Azure DevOps Services e o Docker</span><span class="sxs-lookup"><span data-stu-id="c4a7c-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="c4a7c-124">A CI surgiu como um padrão para testar e fornecer softwares modernos.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="c4a7c-125">A solução do Docker mantém uma separação clara entre as preocupações das equipes de desenvolvimento e de operações.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="c4a7c-126">A imutabilidade das imagens do Docker garante uma implantação repetível entre o que é desenvolvido, testado por meio de CI e executado em produção.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="c4a7c-127">O Mecanismo do Docker implantado nos laptops e na infraestrutura de teste do desenvolvedor torna os contêineres portáteis entre ambientes.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="c4a7c-128">Neste ponto, quando tiver um sistema de controle de versão com o código correto enviado, você precisará de um *serviço de build* para usar o código e executar o build e os testes globais.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="c4a7c-129">O fluxo de trabalho interno desta etapa (CI, build, teste) é focado na construção de um pipeline de CI composto pelo repositório de código (Git etc.), pelo servidor de build (Azure DevOps Services), o Mecanismo do Docker e um Registro do Docker.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="c4a7c-130">Você pode usar o Azure DevOps Services como base para criar seus aplicativos e configurar seu pipeline de CI, bem como para publicar os "artefatos" criados em um "repositório de artefatos", o que é explicado na próxima etapa.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="c4a7c-131">Ao usar o Docker para a implantação, os "artefatos finais" a serem implantados são imagens do Docker com seu aplicativo ou serviços inseridos.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="c4a7c-132">Essas imagens são enviadas por push ou publicadas em um *Registro do Docker* (um repositório privado, como os que você pode ter no Registro de Contêiner do Azure, ou um público, como o Registro do Docker Hub, que costuma ser usado para imagens de base oficiais).</span><span class="sxs-lookup"><span data-stu-id="c4a7c-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="c4a7c-133">Este é o conceito básico: o pipeline de CI será iniciado por uma confirmação para um repositório SCC, como o git.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="c4a7c-134">A confirmação ("commit") fará com que o Azure DevOps Services execute um trabalho de build dentro de um contêiner do Docker e, após a conclusão bem-sucedida do trabalho, efetuar push de uma imagem do Docker para o Registro do Docker, conforme ilustrado na Figura 5-2.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="c4a7c-135">A primeira parte do loop externo envolve as etapas de 1 a 3, de código, execução, depuração e validação, depois o repositório de código até a etapa compilar e testar CI.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![Diagrama mostrando as três etapas envolvidas no fluxo de trabalho de CI.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="c4a7c-137">**Figura 5-2**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-137">**Figure 5-2**.</span></span> <span data-ttu-id="c4a7c-138">As etapas envolvidas na CI</span><span class="sxs-lookup"><span data-stu-id="c4a7c-138">The steps involved in CI</span></span>

<span data-ttu-id="c4a7c-139">Estas são as etapas básicas do fluxo de trabalho de CI com o Docker e o Azure DevOps Services:</span><span class="sxs-lookup"><span data-stu-id="c4a7c-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="c4a7c-140">O desenvolvedor envia por push uma confirmação ("commit") para um repositório de SCC (Git/Azure DevOps Services, GitHub etc.).</span><span class="sxs-lookup"><span data-stu-id="c4a7c-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="c4a7c-141">Se você está usando o Azure DevOps Services ou o Git, a CI é interna, o que significa que ela é tão simples quanto marcar uma caixa de seleção no Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="c4a7c-142">Se você estiver usando um SCC externo (como o GitHub), um `webhook` notificará o Azure DevOps Services da atualização ou do push para o Git/GitHub.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="c4a7c-143">O Azure DevOps Services efetua pull do repositório de SCC, incluindo o Dockerfile descrevendo a imagem, bem como do código do aplicativo e de teste.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="c4a7c-144">O Azure DevOps Services cria uma imagem do Docker e a rotula com um número de build.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="c4a7c-145">O Azure DevOps Services cria uma instância do contêiner do Docker no Host do Docker provisionado e executa os testes apropriados.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="c4a7c-146">Se os testes forem bem-sucedidos, primeiro a imagem será rotulada novamente com um nome significativo, para que você saiba que se trata de um "build privilegiado" (como "/ 1.0.0" ou qualquer outro rótulo) e, em seguida, enviada por push para seu Registro do Docker (Docker Hub, Registro de Contêiner do Azure, DTR etc.)</span><span class="sxs-lookup"><span data-stu-id="c4a7c-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="c4a7c-147">Implementando o pipeline de CI com o Azure DevOps Services e a extensão do Docker para Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="c4a7c-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="c4a7c-148">O Azure DevOps Services do Visual Studio contém modelos de Build e Versão que você pode usar no pipeline de CI/CD com que você pode criar imagens do Docker, efetuar push de imagens do Docker para um registro do Docker autenticado, executar imagens do Docker ou executar outras operações oferecidas pela CLI do Docker.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="c4a7c-149">Ele também adiciona uma tarefa de Docker Compose que pode ser usada para efetuar push de aplicativos do Docker de vários contêineres e criá-los e executá-los ou executar outras operações oferecidas pela CLI do Docker Compose, conforme mostrado na Figura 5-3.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Captura de tela do pipeline do Docker CI no Azure DevOps.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="c4a7c-151">**Figura 5-3**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-151">**Figure 5-3**.</span></span> <span data-ttu-id="c4a7c-152">O pipeline de CI do Docker no Azure DevOps Services, incluindo modelos de Build e Versão e as tarefas associadas.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="c4a7c-153">Você pode usar esses modelos e tarefas para construir seus artefatos de CI/CD para build/teste e implantação no Service Fabric do Azure, no Serviço de Kubernetes do Azure e em ofertas semelhantes.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="c4a7c-154">Com essas tarefas do Visual Studio Team Services, um Host/VM de build do Linux-Docker provisionado no Azure e o registro do Docker de sua preferência (Registro de Contêiner do Azure, Docker Hub, DTR privado do Docker ou qualquer outro registro do Docker), você pode montar seu pipeline de CI do Docker de maneira muito consistente.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="c4a7c-155">\**_Requisitos:_* _</span><span class="sxs-lookup"><span data-stu-id="c4a7c-155">\**_Requirements:_* _</span></span>

- <span data-ttu-id="c4a7c-156">Azure DevOps Services ou, para instalações locais, Team Foundation Server 2015, Atualização 3 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="c4a7c-157">Um agente do Azure DevOps Services que tem os binários de Docker.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="c4a7c-158">Uma maneira fácil de criar um desses agentes é usar o Docker para executar um contêiner baseado na imagem do Docker de agente do Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> <span data-ttu-id="c4a7c-159">[!INFORMAÇÕES] Para ler mais sobre como montar um pipeline de CI do Docker do Azure DevOps Services e exibir as instruções passo a passo, visite estes sites:</span><span class="sxs-lookup"><span data-stu-id="c4a7c-159">[!INFORMATION] To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="c4a7c-160">Como executar um agente do Visual Studio Team Services (agora, Azure DevOps Services) como um contêiner do Docker: </span><span class="sxs-lookup"><span data-stu-id="c4a7c-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="c4a7c-161">Criando imagens do Docker do .NET Linux com Azure DevOps Services: </span><span class="sxs-lookup"><span data-stu-id="c4a7c-161">Building .NET Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="c4a7c-162">Como criar um computador de build do Visual Studio Team Services baseada em Linux com suporte para Docker: </span><span class="sxs-lookup"><span data-stu-id="c4a7c-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <https://www.donovanbrown.com/post/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="c4a7c-163">Integrar, testar e validar aplicativos do Docker com vários contêineres</span><span class="sxs-lookup"><span data-stu-id="c4a7c-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="c4a7c-164">Normalmente, a maioria dos aplicativos do Docker são compostos por vários contêineres em vez de apenas um.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="c4a7c-165">Um bom exemplo é um aplicativo orientado a microsserviços para o qual você teria um contêiner por microsserviço.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="c4a7c-166">Entretanto, mesmo sem seguir estritamente os padrões da abordagem de microsserviços, é provável que seu aplicativo do Docker seja composto por vários contêineres ou serviços.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="c4a7c-167">Portanto, após criar os contêineres de aplicativo no pipeline de CI, você também precisará implantar, integrar e testar o aplicativo como um todo, com todos os seus contêineres dentro de um host do Docker de integração ou até mesmo em um cluster de teste para o qual seus contêineres são distribuídos.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="c4a7c-168">Se estiver usando um único host, você poderá usar comandos do Docker, como docker-compose, para compilar e implantar contêineres relacionados ao testar e à validação do ambiente do Docker em uma única VM.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="c4a7c-169">No entanto, se estiver trabalhando com um cluster de orquestrador, como Docker Swarm, Kubernetes ou DC/OS, você precisará implantar seus contêineres por meio de um mecanismo ou orquestrador diferente, dependendo do cluster/agendador selecionado.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="c4a7c-170">Estes são vários tipos de testes que podem ser executados em contêineres do Docker:</span><span class="sxs-lookup"><span data-stu-id="c4a7c-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="c4a7c-171">Testes de unidade para contêineres do Docker</span><span class="sxs-lookup"><span data-stu-id="c4a7c-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="c4a7c-172">Grupos de testes de aplicativos ou microsserviços inter-relacionados</span><span class="sxs-lookup"><span data-stu-id="c4a7c-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="c4a7c-173">Teste em versões de produção e "canário"</span><span class="sxs-lookup"><span data-stu-id="c4a7c-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="c4a7c-174">O ponto importante é que, ao executar testes de integração e funcionais, você precisa executar esses testes de fora dos contêineres.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="c4a7c-175">Testes não são contidos nem executados nos contêineres que você está implantando, pois os contêineres se baseiam em imagens estáticas que devem ser exatamente iguais às que você implantará para produção.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="c4a7c-176">Uma opção prática ao testar cenários mais avançados, como incluir vários clusters (cluster de produção, de preparo e de teste), é publicar as imagens em um registro, para que possa ser testada em vários clusters.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="c4a7c-177">Efetue push da imagem do Docker do aplicativo personalizado para seu Registro do Docker global</span><span class="sxs-lookup"><span data-stu-id="c4a7c-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="c4a7c-178">Após as imagens do Docker serem testadas e validadas, convém marcar e publicá-las em seu registro do Docker.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="c4a7c-179">O registro do Docker é uma peça fundamental no ciclo de vida do aplicativo do Docker, pois é o local central no qual você armazena seu teste personalizado (também conhecido como "imagens privilegiadas") para implantação em ambientes de produção e de garantia de qualidade.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="c4a7c-180">De modo semelhante a como o código do aplicativo armazenado em seu repositório de SCC (Git etc.) é sua "fonte da verdade", o registro do Docker é a "fonte da verdade" de seus bits ou aplicativo binário a ser implantado nos ambientes de produção ou garantia de qualidade.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="c4a7c-181">Normalmente, você pode querer ter repositórios privados para suas imagens personalizadas em um repositório privado no Registro de Contêiner do Azure ou em um registro local, como o Docker Trusted Registry, ou em um registro de nuvem pública com acesso restrito (como o Docker Hub). Neste último caso, se o código não for software livre, você precisará confiar na segurança do fornecedor.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="c4a7c-182">De qualquer forma, o método usado é semelhante e é baseado no comando `docker push`, conforme mostrado na Figura 5-4.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Diagrama mostrando o envio de imagens personalizadas para um registro de contêiner.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="c4a7c-184">_ \* Figura 5-4 \* \*.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-184">_\*Figure 5-4\*\*.</span></span> <span data-ttu-id="c4a7c-185">Publicando imagens personalizadas no Registro do Docker</span><span class="sxs-lookup"><span data-stu-id="c4a7c-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="c4a7c-186">Na etapa 3, para integração e teste (CI) do build, você pode publicar as imagens do Docker resultantes em um registro público ou privado.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="c4a7c-187">Há várias ofertas de registros do Docker de fornecedores de nuvem, como o Registro de Contêiner do Azure, o Registro de Contêiner do Amazon Web Services, o Registro de Contêiner do Google, o Registro Quay e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="c4a7c-188">Usando as tarefas do Docker, você pode efetuar push de um conjunto de imagens de serviço definidas por um arquivo `docker-compose.yml`, com várias marcas, para um registro do Docker autenticado (como o Registro de Contêiner do Azure), conforme mostrado na Figura 5-5.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Captura de tela mostrando a etapa para publicar imagens em um registro.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="c4a7c-190">**Figura 5-5**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-190">**Figure 5-5**.</span></span> <span data-ttu-id="c4a7c-191">Usando o Azure DevOps Services para publicar imagens personalizadas em um Registro do Docker</span><span class="sxs-lookup"><span data-stu-id="c4a7c-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> <span data-ttu-id="c4a7c-192">[!INFORMAÇÕES] Para obter mais informações sobre o Registro de Contêiner do Azure, consulte <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-192">[!INFORMATION] For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="c4a7c-193">Etapa 4: CD, implantar</span><span class="sxs-lookup"><span data-stu-id="c4a7c-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="c4a7c-194">A imutabilidade das imagens do Docker garante uma implantação repetível com relação ao que é desenvolvido, testado por meio de CI e executado em produção.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="c4a7c-195">Depois de ter as imagens de Docker do aplicativo publicadas em seu registro do Docker (público ou privado), você pode implantá-las em vários ambientes (produção, garantia de qualidade, preparo etc.) de seu pipeline de CD usando tarefas de pipeline do Azure DevOps Services ou o Release Management do Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="c4a7c-196">No entanto, neste ponto, depende do tipo de aplicativo do Docker você está usando.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="c4a7c-197">Implantar um aplicativo simples (do ponto de vista da composição e implantação), como um aplicativo monolítico composto por alguns contêineres ou serviços e implantado em alguns servidores ou VMs, é diferente de implantar um aplicativo mais complexo, como um aplicativo orientado a microsserviços com recursos em hiperescala.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="c4a7c-198">Esses dois cenários são explicados nas seções a seguir.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="c4a7c-199">Implantando aplicativos de Docker compostos em vários ambientes do Docker</span><span class="sxs-lookup"><span data-stu-id="c4a7c-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="c4a7c-200">Primeiro, vamos ver o cenário menos complexo: implantar em hosts de Docker simples (VMs ou servidores) em um único ambiente ou em vários ambientes (garantia de qualidade, preparo e produção).</span><span class="sxs-lookup"><span data-stu-id="c4a7c-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="c4a7c-201">Neste cenário, internamente, seu pipeline de CD pode usar docker-compose (das tarefas de implantação do Azure DevOps Services) para implantar os aplicativos do Docker com o conjunto relacionado de contêineres ou serviços, conforme ilustrado na Figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Diagrama que mostra a etapa de implantação do CD implantando em três ambientes.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="c4a7c-203">**Figura 5-6**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-203">**Figure 5-6**.</span></span> <span data-ttu-id="c4a7c-204">Implantando contêineres de aplicativo no registro de ambientes de host de Docker simples</span><span class="sxs-lookup"><span data-stu-id="c4a7c-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="c4a7c-205">A Figura 5-7 destaca como você pode conectar sua CI de build a ambientes de garantia de qualidade/teste por meio do Azure DevOps Services clicando em Docker Compose na caixa de diálogo Adicionar Tarefa.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="c4a7c-206">No entanto, ao implantar em ambientes de preparo ou produção, normalmente você usaria recursos do Release Management que lidam com vários ambientes (como garantia de qualidade, preparo e produção).</span><span class="sxs-lookup"><span data-stu-id="c4a7c-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="c4a7c-207">Se você está implantando em hosts do Docker únicos, ele está usando a tarefa "Docker Compose" do Azure DevOps Services (que está invocando o comando `docker-compose up` nos bastidores).</span><span class="sxs-lookup"><span data-stu-id="c4a7c-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="c4a7c-208">Se você está implantando no AKS (Serviço de Kubernetes do Azure), ele usa a tarefa Implantação do Docker, conforme explicado na seção a seguir.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Captura de tela mostrando a caixa de diálogo adicionar tarefas da tarefa Docker Compose.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="c4a7c-210">**Figura 5-7**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-210">**Figure 5-7**.</span></span> <span data-ttu-id="c4a7c-211">Adicionando uma tarefa Docker Compose em um pipeline do Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="c4a7c-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="c4a7c-212">Quando você cria uma versão no Azure DevOps Services, ele usa um conjunto de artefatos de entrada.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="c4a7c-213">Esses artefatos devem ser imutáveis durante o tempo de vida da versão, em todos os ambientes.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="c4a7c-214">Quando você introduz contêineres, os artefatos de entrada identificam imagens em um registro para implantação.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="c4a7c-215">Dependendo de como essas imagens estão identificadas, não há garantia de que permaneçam as mesmas pela duração da versão, sendo o caso mais óbvio quando você referencia `myimage:latest` de um arquivo `docker-compose`.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="c4a7c-216">Os modelos do Azure DevOps Services permitem gerar artefatos de build que contêm resumos de imagens específicas do registro que, certamente, identificarão exclusivamente o mesmo binário da imagem.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="c4a7c-217">Eles devem ser usados como entrada para uma versão.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="c4a7c-218">Gerenciando versões para ambientes do Docker usando o Release Management do Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="c4a7c-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="c4a7c-219">Por meio dos modelos do Azure DevOps Services, você pode criar uma nova imagem, publicá-la em um registro do Docker, executá-la em hosts Linux ou Windows e usar comandos como `docker-compose` para implantar vários contêineres como um aplicativo inteiro, tudo isso por meio das funcionalidades de Release Management do Azure DevOps Services destinadas a vários ambientes, conforme mostrado na Figura 5-8.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Captura de tela mostrando a configuração das versões do Docker Compose.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="c4a7c-221">**Figura 5-8**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-221">**Figure 5-8**.</span></span> <span data-ttu-id="c4a7c-222">Configurando tarefas de Docker Compose do Azure DevOps Services do Release Management do Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="c4a7c-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="c4a7c-223">No entanto, tenha em mente que o cenário mostrado na Figura 5-6 e implementado na Figura 5-8 é simples (ele está implantando VMs e hosts únicos do Docker e haverá um único contêiner ou instância por imagem) e provavelmente deveria ser usada apenas para cenários de desenvolvimento ou teste.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="c4a7c-224">Na maioria dos cenários de produção corporativos, você gostaria de ter HA (alta disponibilidade) e escalabilidade de fácil gerenciamento por meio do balanceamento de carga entre vários nós, servidores e VMs, além de "failovers inteligentes", de forma que, se um servidor ou nó falhar, seus serviços e contêineres serão movidos para outro servidor de host ou VM.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="c4a7c-225">Nesse caso, você precisa de tecnologias mais avançadas, como clusters de contêiner, orquestradores e agendadores.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="c4a7c-226">Assim, a maneira de implantar esses clusters é manipulando os cenários avançados explicados na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="c4a7c-227">Implantando aplicativos do Docker em clusters do Docker</span><span class="sxs-lookup"><span data-stu-id="c4a7c-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="c4a7c-228">A natureza dos aplicativos distribuídos exige recursos de computação que também são distribuídos.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="c4a7c-229">Para ter funcionalidades em escala de produção, você precisa ter funcionalidades de clustering que fornecem alta escalabilidade e alta disponibilidade com base em recursos em pool.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="c4a7c-230">Você poderia implantar contêineres manualmente nesses clusters de uma ferramenta de CLI ou de uma interface do usuário da Web, mas você deveria reservar esse tipo de trabalho manual para finalidades de teste e gerenciamento de implantação especial, como expansão ou monitoramento.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="c4a7c-231">Do ponto de vista da CD e especificamente do Azure DevOps Services, você pode executar tarefas de implantação feitas especialmente de seus ambientes de Release Management do Azure DevOps Services que implantarão seus aplicativos em contêineres em clusters distribuídos no Serviço de Contêiner, conforme ilustrado na Figura 5-9.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Diagrama que mostra a etapa de implantação do CD implantando em orquestradores.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="c4a7c-233">**Figura 5-9**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-233">**Figure 5-9**.</span></span> <span data-ttu-id="c4a7c-234">Implantando aplicativos distribuídos no Serviço de Contêiner</span><span class="sxs-lookup"><span data-stu-id="c4a7c-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="c4a7c-235">Inicialmente, ao implantar em determinados clusters ou orquestradores, tradicionalmente você usaria scripts de implantação e mecanismos específicos a cada orquestrador (ou seja, o Kubernetes e o Service Fabric têm mecanismos de implantação diferentes) em vez da ferramenta `docker-compose`, mais simples e mais fácil de usar, no arquivo de definição `docker-compose.yml`.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="c4a7c-236">No entanto, graças à tarefa de implantação do Docker Azure DevOps Services, mostrada na Figura 5-10, agora você também pode implantar nos orquestradores com suporte usando apenas seu arquivo familiar, `docker-compose.yml` pois a ferramenta executa essa "tradução" para você (de seu `docker-compose.yml` arquivo para o formato necessário para o orquestrador).</span><span class="sxs-lookup"><span data-stu-id="c4a7c-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Captura de tela mostrando a tarefa implantar no kubernetes.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="c4a7c-238">**Figura 5-10**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-238">**Figure 5-10**.</span></span> <span data-ttu-id="c4a7c-239">Adicionando a tarefa Implantar no Kubernetes ao seu ambiente</span><span class="sxs-lookup"><span data-stu-id="c4a7c-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="c4a7c-240">A Figura 5-11 demonstra como você pode editar o a tarefa Implantar no Kubernetes com as seções disponíveis para configuração.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="c4a7c-241">Esta é a tarefa que recuperará as imagens do Docker personalizadas prontas para uso para implantação como contêineres no cluster.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Captura de tela mostrando a configuração de tarefa implantar em kubernetes.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="c4a7c-243">**Figura 5-11**.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-243">**Figure 5-11**.</span></span> <span data-ttu-id="c4a7c-244">Definição da tarefa Implantação do Docker em CD/SO do ACS</span><span class="sxs-lookup"><span data-stu-id="c4a7c-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> <span data-ttu-id="c4a7c-245">[!INFORMAÇÕES] Para ler mais sobre o pipeline de CD com o Azure DevOps Services e o Docker, visite <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="c4a7c-245">[!INFORMATION] To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="c4a7c-246">Etapa 5: executar e gerenciar</span><span class="sxs-lookup"><span data-stu-id="c4a7c-246">Step 5: Run and manage</span></span>

<span data-ttu-id="c4a7c-247">Uma vez que executar e gerenciar aplicativos no nível de produção empresarial é um tema maior e devido ao tipo de operações e de pessoas que trabalham nesse nível (operações de TI), bem como ao escopo grande desta área, o próximo capítulo inteiro é dedicado a explicá-lo.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="c4a7c-248">Etapa 6: monitorar e diagnosticar</span><span class="sxs-lookup"><span data-stu-id="c4a7c-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="c4a7c-249">Este tópico também é abordado no próximo capítulo como parte das tarefas que a TI executa em sistemas de produção. No entanto, é importante destacar que os insights obtidos nesta etapa devem ser informados à equipe de desenvolvimento para que o aplicativo seja aprimorado constantemente.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="c4a7c-250">Desse ponto de vista, ele também faz parte de DevOps, embora as operações e tarefas normalmente sejam executadas pela TI.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="c4a7c-251">Somente quando o monitoramento e o diagnóstico estão 100% dentro do realm do DevOps, os processos de monitoramento e análise são realizados pela equipe de desenvolvimento em ambientes de teste ou beta.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="c4a7c-252">Isso é feito executando testes de carga ou monitorando ambientes de garantia de qualidade ou beta, em que testadores beta testam as novas versões.</span><span class="sxs-lookup"><span data-stu-id="c4a7c-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="c4a7c-253">[Anterior](index.md) 
> [Avançar](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="c4a7c-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
